<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>dubbo(一):初探以及使用</title>
      <link href="/2019/07/14/dubbo-%E4%B8%80-%E5%88%9D%E6%8E%A2%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/07/14/dubbo-%E4%B8%80-%E5%88%9D%E6%8E%A2%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考:官网 <a href="http://dubbo.apache.org/zh-cn/docs/user/quick-start.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/user/quick-start.html</a> <br><br>参考:<a href="https://www.bilibili.com/video/av30612478" target="_blank" rel="noopener">https://www.bilibili.com/video/av30612478</a></p></blockquote><h2 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Windows:10</span><br><span class="line">Linux:centos6.5</span><br><span class="line">jdk:1.8</span><br><span class="line">zookeeper:zookeeper-3.4.14</span><br><span class="line">Dubbo-Admin:0.1版本,基于Dubbo 2.7最新版本</span><br><span class="line">Dubbo:2.7</span><br></pre></td></tr></table></figure><h2 id="1-分布式基础理论"><a href="#1-分布式基础理论" class="headerlink" title="1.分布式基础理论"></a>1.分布式基础理论</h2><h3 id="1-1-什么是分布式系统"><a href="#1-1-什么是分布式系统" class="headerlink" title="1.1 什么是分布式系统?"></a>1.1 什么是分布式系统?</h3><p>《分布式系统原理与范型》定义：<br></p><pre><code>分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统分布式系统（distributed system）是建立在网络之上的软件系统。</code></pre><p>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。</p><h3 id="1-2-发展演变"><a href="#1-2-发展演变" class="headerlink" title="1.2 发展演变"></a>1.2 发展演变</h3><p><img src="https://note.youdao.com/yws/public/resource/ac9c41aee95655840b3bad0550c9d7ec/7A7675C44B424BD5BEFE04A9181A47BD" alt="image"></p><h4 id="单一应用架构"><a href="#单一应用架构" class="headerlink" title="单一应用架构"></a>单一应用架构</h4><p>&emsp;&emsp;当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。<br><img src="https://note.youdao.com/yws/public/resource/ac9c41aee95655840b3bad0550c9d7ec/4C6E6CB8D3F349FA9950B3658F820969" alt="image"></p><p>&emsp;&emsp;适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。<br><br>缺点： </p><pre><code>1、性能扩展比较难 2、协同开发问题3、不利于升级维护</code></pre><h4 id="垂直应用架构"><a href="#垂直应用架构" class="headerlink" title="垂直应用架构"></a>垂直应用架构</h4><p>&emsp;&emsp;当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。<br><br><img src="https://note.youdao.com/yws/public/resource/ac9c41aee95655840b3bad0550c9d7ec/EA94F6D8A15E4344AB3D8C39E08D47D2" alt="image"></p><p>&emsp;&emsp;通过切分业务来实现各个模块独立部署，降低了维护和部署的难度，团队各司其职更易管理，性能扩展也更方便，更有针对性。<br>&emsp;&emsp;缺点： 公用模块无法重复利用，开发性的浪费</p><h4 id="分布式服务架构"><a href="#分布式服务架构" class="headerlink" title="分布式服务架构"></a>分布式服务架构</h4><p>&emsp;&emsp;当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的<font color="#5B9BD5">分布式服务框架(RPC)</font>是关键。</p><p><img src="https://note.youdao.com/yws/public/resource/ac9c41aee95655840b3bad0550c9d7ec/C21D92BAAB664B90A199398D25F659FE" alt="image"></p><h4 id="流动计算架构"><a href="#流动计算架构" class="headerlink" title="流动计算架构"></a>流动计算架构</h4><p>&emsp;&emsp;当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于<strong>提高机器利用率的资源调度和治理中心</strong><font color="red">(SOA)[ Service Oriented Architecture]</font><strong>是关键</strong>。</p><p><img src="https://note.youdao.com/yws/public/resource/ac9c41aee95655840b3bad0550c9d7ec/3F1A57556B864F76AC7E1D5207AF1E9C" alt="image"></p><h4 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h4><p>&emsp;&emsp;微服务是系统架构上的一种设计风格，它的主旨是将一个原本独立的系统拆分成多个小型服务，这些小型服务都在各自独立的进程中运行，服务之间通过基于HTTP的RESTful API进行通信协作。被拆分成的每一个小型服务都围绕着系统中的某一项或一些耦合度较高的业务功能进行构建，并且每个服务都维护着<strong>自身的数据存储</strong>、<strong>业务开发</strong>、<strong>自动化测试案例</strong>以及<strong>独立部署机制</strong>。由于有了轻量级的通信协作基础，所以这些微服务可以使用不同的语言来编写。<br></p><p>&emsp;&emsp;以电影售票系统为例，使用微服务来架构该应用,架构图如下:<br><img src="https://note.youdao.com/yws/public/resource/ac9c41aee95655840b3bad0550c9d7ec/3D94E66B7713416BB52ECEC7FF5EC699" alt="image"></p><h3 id="1-3-RPC"><a href="#1-3-RPC" class="headerlink" title="1.3 RPC"></a>1.3 RPC</h3><h4 id="什么叫RPC"><a href="#什么叫RPC" class="headerlink" title="什么叫RPC"></a>什么叫RPC</h4><p>RPC【Remote Procedure Call】是<strong>指远程过程调用</strong>，是一种<strong>进程间通信方式</strong>，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。</p><h4 id="RPC基本原理"><a href="#RPC基本原理" class="headerlink" title="RPC基本原理"></a>RPC基本原理</h4><p><img src="https://note.youdao.com/yws/public/resource/ac9c41aee95655840b3bad0550c9d7ec/67EB3B0B589F4FD08F4DAD00DA5A124C" alt="image"><br></p><p><img src="https://note.youdao.com/yws/public/resource/ac9c41aee95655840b3bad0550c9d7ec/E56837B3247744B0B2B20950BA7DAF1B" alt="image"></p><p><strong>RPC两个核心模块：<font color="red">通讯，序列化。</font></strong></p><p>RPC框架有很多如：<br><br>dubbo、gRPC、Thrift、HSF（High Speed Service Framework）</p><h2 id="2-Dubbo核心概念"><a href="#2-Dubbo核心概念" class="headerlink" title="2. Dubbo核心概念"></a>2. Dubbo核心概念</h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p>&emsp;&emsp;Apache Dubbo (incubating) |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。<br><br>官网：<br><br><a href="http://dubbo.apache.org/" target="_blank" rel="noopener">http://dubbo.apache.org/</a><br></p><p><img src="https://note.youdao.com/yws/public/resource/ac9c41aee95655840b3bad0550c9d7ec/39A1B6B3FCE64FA1A6574E6503BC50DA" alt="image"></p><h3 id="2-2-基本概念"><a href="#2-2-基本概念" class="headerlink" title="2.2 基本概念"></a>2.2 基本概念</h3><p><img src="https://note.youdao.com/yws/public/resource/ac9c41aee95655840b3bad0550c9d7ec/AF10BF98B9AF4AC8AC90C459FA8E389D" alt="image"></p><p>&emsp;&emsp;<strong>服务运行容器（Container）:</strong><br>负责启动，加载，运行服务提供者</p><p>&emsp;&emsp;<strong>服务提供者（Provider）:</strong><br>暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。</p><p>&emsp;&emsp;<strong>服务消费者（Consumer）:</strong> 调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p><p>&emsp;&emsp;<strong>注册中心（Registry）:</strong><br>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者</p><p>&emsp;&emsp;<strong>监控中心（Monitor）:</strong><br>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心</p><hr><p>调用关系说明:</p><ul><li>服务容器负责启动，加载，运行服务提供者。</li><li>服务提供者在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ul><hr><h3 id="2-3-特性"><a href="#2-3-特性" class="headerlink" title="2.3 特性"></a>2.3 特性</h3><blockquote><p>参考:<a href="http://dubbo.apache.org/zh-cn/docs/user/preface/architecture.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/user/preface/architecture.html</a></p></blockquote><p><img src="https://note.youdao.com/yws/public/resource/ac9c41aee95655840b3bad0550c9d7ec/077EE809D0DD4934AE8DE41B04CA0CE2" alt="image"></p><h2 id="3-Dubbo环境搭建"><a href="#3-Dubbo环境搭建" class="headerlink" title="3 Dubbo环境搭建"></a>3 Dubbo环境搭建</h2><h3 id="3-1-windows环境"><a href="#3-1-windows环境" class="headerlink" title="3.1 [windows环境]"></a>3.1 [windows环境]</h3><h4 id="安装zookeeper"><a href="#安装zookeeper" class="headerlink" title="安装zookeeper"></a>安装zookeeper</h4><p>搭建单机伪集群:<br><br><a href="https://blog.csdn.net/yhl_jxy/article/details/77752725" target="_blank" rel="noopener">https://blog.csdn.net/yhl_jxy/article/details/77752725</a><br><br><a href="https://blog.csdn.net/weixin_34161029/article/details/88107059" target="_blank" rel="noopener">https://blog.csdn.net/weixin_34161029/article/details/88107059</a><br></p><p>1.下载zookeeper<br><br>网址 <a href="https://archive.apache.org/dist/zookeeper/zookeeper-3.4.14/" target="_blank" rel="noopener">https://archive.apache.org/dist/zookeeper/zookeeper-3.4.14/</a> <br><br>2.解压zookeeper-3.4.14.tar.gz并复制三份如下:<br><br><img src="https://note.youdao.com/yws/public/resource/ac9c41aee95655840b3bad0550c9d7ec/20B73E597CF9412A9966A8494D204C30" alt="image"><br>3.将conf下的zoo_sample.cfg复制一份改名为zoo.cfg,三份内容如下:<br><br><code>zookeeper_node1</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># The number of milliseconds of each tick</span><br><span class="line">tickTime=2000</span><br><span class="line"># The number of ticks that the initial </span><br><span class="line"># synchronization phase can take</span><br><span class="line">initLimit=10</span><br><span class="line"># The number of ticks that can pass between </span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line">syncLimit=5</span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line"># do not use /tmp for storage, /tmp here is just </span><br><span class="line"># example sakes.</span><br><span class="line">dataLogDir=E:\\Java_Tools\\zookeeper_cluster\\zookeeper_node1\\logs</span><br><span class="line">dataDir=E:\\Java_Tools\\zookeeper_cluster\\zookeeper_node1\\data</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort=2181</span><br><span class="line">server.1=127.0.0.1:2881:3881</span><br><span class="line">server.2=127.0.0.1:2882:3882</span><br><span class="line">server.3=127.0.0.1:2883:3883</span><br></pre></td></tr></table></figure><p><code>zookeeper_node2</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># The number of milliseconds of each tick</span><br><span class="line">tickTime=2000</span><br><span class="line"># The number of ticks that the initial </span><br><span class="line"># synchronization phase can take</span><br><span class="line">initLimit=10</span><br><span class="line"># The number of ticks that can pass between </span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line">syncLimit=5</span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line"># do not use /tmp for storage, /tmp here is just </span><br><span class="line"># example sakes.</span><br><span class="line">dataLogDir=E:\\Java_Tools\\zookeeper_cluster\\zookeeper_node2\\logs</span><br><span class="line">dataDir=E:\\Java_Tools\\zookeeper_cluster\\zookeeper_node2\\data</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort=2182</span><br><span class="line">server.1=127.0.0.1:2881:3881</span><br><span class="line">server.2=127.0.0.1:2882:3882</span><br><span class="line">server.3=127.0.0.1:2883:3883</span><br></pre></td></tr></table></figure><p><code>zookeeper_node3</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># The number of milliseconds of each tick</span><br><span class="line">tickTime=2000</span><br><span class="line"># The number of ticks that the initial </span><br><span class="line"># synchronization phase can take</span><br><span class="line">initLimit=10</span><br><span class="line"># The number of ticks that can pass between </span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line">syncLimit=5</span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line"># do not use /tmp for storage, /tmp here is just </span><br><span class="line"># example sakes.</span><br><span class="line">dataLogDir=E:\\Java_Tools\\zookeeper_cluster\\zookeeper_node3\\logs</span><br><span class="line">dataDir=E:\\Java_Tools\\zookeeper_cluster\\zookeeper_node3\\data</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort=2183</span><br><span class="line">server.1=127.0.0.1:2881:3881</span><br><span class="line">server.2=127.0.0.1:2882:3882</span><br><span class="line">server.3=127.0.0.1:2883:3883</span><br></pre></td></tr></table></figure><p>4.分别在zookeeper_node*/目录下创建<code>data</code>,<code>logs</code>目录,并且在<code>data</code>目录创建文件<code>myid</code>,用来标识集群中节点.,其内容分别为:<br><br><code>zookeeper_cluster\zookeeper_node1\data\myid</code>为:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p><code>zookeeper_cluster\zookeeper_node2\data\myid</code>为:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p><code>zookeeper_cluster\zookeeper_node3\data\myid</code>为:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>5 .分别启动三个zookeeper实例<br><br>运行<code>zookeeper_cluster\zookeeper_node1\bin\zkServer.cmd</code></p><p>注:windows10下双击zkServer.cmd，发现闪退,进入bin文件夹，打开zkServer.cmd进行编辑，在尾部加pause<br>6.使用./zkCli.cmd测试,分别连接三台zookeeper</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E:\Java_Tools\zookeeper_cluster\zookeeper_node3\bin&gt; .\zkCli.cmd -server 127.0.0.1:2181</span><br><span class="line"></span><br><span class="line">E:\Java_Tools\zookeeper_cluster\zookeeper_node3\bin&gt; .\zkCli.cmd -server 127.0.0.1:2182</span><br><span class="line"></span><br><span class="line">E:\Java_Tools\zookeeper_cluster\zookeeper_node3\bin&gt; .\zkCli.cmd -server 127.0.0.1:2183</span><br></pre></td></tr></table></figure><p><img src="https://note.youdao.com/yws/public/resource/ac9c41aee95655840b3bad0550c9d7ec/2F85E8C6D71B4472BEC78BB2BA1B090C" alt="image"><br><img src="https://note.youdao.com/yws/public/resource/ac9c41aee95655840b3bad0550c9d7ec/F943E7DEAC93429787CF6F34149A12D8" alt="image"><br><img src="https://note.youdao.com/yws/public/resource/ac9c41aee95655840b3bad0550c9d7ec/CEC95CC72E3844809F6F64C3D3F1330E" alt="image"></p><p>zookeeper集群搭建成功</p><h4 id="安装dubbo-admin管理控制台"><a href="#安装dubbo-admin管理控制台" class="headerlink" title="安装dubbo-admin管理控制台"></a>安装dubbo-admin管理控制台</h4><blockquote><p>参考:<a href="https://github.com/apache/dubbo-admin/blob/develop/README_ZH.md" target="_blank" rel="noopener">https://github.com/apache/dubbo-admin/blob/develop/README_ZH.md</a> <br><br>如果出现无元数据参考:<a href="https://github.com/apache/dubbo-admin/issues/298" target="_blank" rel="noopener">https://github.com/apache/dubbo-admin/issues/298</a> <br><br><a href="http://dubbo.apache.org/zh-cn/docs/user/configuration/config-center.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/user/configuration/config-center.html</a></p></blockquote><p>&emsp;&emsp;dubbo本身并不是一个服务软件。它其实就是一个jar包能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。所以你不用在Linux上启动什么dubbo服务。<br><br>但是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序，不过这个监控即使不装也不影响使用。</p><ol><li><p>下载dubbo-admin<br><a href="https://github.com/apache/dubbo-admin" target="_blank" rel="noopener">https://github.com/apache/dubbo-admin</a></p></li><li><p>进入目录，修改dubbo-admin配置<br>修改 src\main\resources\application.properties 指定zookeeper地址</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># centers in dubbo2.7</span><br><span class="line">admin.registry.address=zookeeper://127.0.0.1:2181?backup=127.0.0.1:2182,127.0.0.1:2183</span><br><span class="line">admin.config-center=zookeeper://127.0.0.1:2181?backup=127.0.0.1:2182,127.0.0.1:2183</span><br><span class="line">admin.metadata-report.address=zookeeper://127.0.0.1:2181?backup=127.0.0.1:2182,127.0.0.1:2183</span><br><span class="line"></span><br><span class="line">#group</span><br><span class="line">admin.registry.group=dubbo</span><br><span class="line">admin.config-center.group=dubbo</span><br><span class="line">admin.metadata-report.group=dubbo</span><br><span class="line">#admin.root.password=root</span><br><span class="line">#admin.guest.password=guest</span><br><span class="line">admin.apollo.token=e16e5cd903fd0c97a116c873b448544b9d086de9</span><br><span class="line">admin.apollo.appId=test</span><br><span class="line">admin.apollo.env=dev</span><br><span class="line">admin.apollo.cluster=default</span><br><span class="line">admin.apollo.namespace=dubbo</span><br></pre></td></tr></table></figure></li><li><p>打包dubbo-admin<br><br> 第一种方式:(建议)<br><br> 进入<code>\dubbo-admin\dubbo-admin-server</code>目录<br><br> 运行:<code>mvn clean package</code> 或者<code>mvn clean install -DskipTests</code>在<code>target</code>目录可看到打好的<code>jar</code>包</p><p> 第二种方式:<br><br> 或者在根目录<code>\dubbo-admin</code>运行<code>mvn clean package</code>,然后进入<code>dubbo-admin\dubbo-admin-distribution\target</code>目录可看到打好的<code>jar</code>包</p></li><li><p>运行dubbo-admin <br><br><code>java -jar dubbo-admin-0.1.jar</code></p></li><li><p>访问<code>http://localhost:8080</code><br><img src="https://note.youdao.com/yws/public/resource/ac9c41aee95655840b3bad0550c9d7ec/0B2D7A9DA25043189C7B15FC8C08D4E9" alt="image"></p></li></ol><h3 id="3-2-Linux环境"><a href="#3-2-Linux环境" class="headerlink" title="3.2 [Linux环境]"></a>3.2 [Linux环境]</h3><h4 id="安装zookeeper-1"><a href="#安装zookeeper-1" class="headerlink" title="安装zookeeper"></a>安装zookeeper</h4><p> 和<code>windows</code>环境大同小异<br><br> 可参考(云笔记里面的activemq中的zookeeper集群安装):<a href="http://note.youdao.com/noteshare?id=edf4e95372ab25b48432392e3df56fdc" target="_blank" rel="noopener">http://note.youdao.com/noteshare?id=edf4e95372ab25b48432392e3df56fdc</a></p><h4 id="安装dubbo-admin管理控制台-1"><a href="#安装dubbo-admin管理控制台-1" class="headerlink" title="安装dubbo-admin管理控制台"></a>安装dubbo-admin管理控制台</h4><p>直接把打好的<code>jar</code>包<code>dubbo-admin-0.1.jar</code>复制到<code>linux</code>服务器,然后运行<code>java -jar dubbo-admin-0.1.jar</code>即可</p><h2 id="4-使用Dubbo"><a href="#4-使用Dubbo" class="headerlink" title="4 使用Dubbo"></a>4 使用Dubbo</h2><h3 id="4-1-简单使用"><a href="#4-1-简单使用" class="headerlink" title="4.1 简单使用"></a>4.1 简单使用</h3><blockquote><p>参考:<a href="http://dubbo.apache.org/zh-cn/docs/user/quick-start.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/user/quick-start.html</a> <br></p></blockquote><h4 id="工程架构"><a href="#工程架构" class="headerlink" title="工程架构"></a>工程架构</h4><p>根据dubbo官网文档<a href="http://dubbo.apache.org/zh-cn/docs/user/best-practice.html" target="_blank" rel="noopener">服务化最佳实践</a></p><p><img src="https://note.youdao.com/yws/public/resource/ac9c41aee95655840b3bad0550c9d7ec/E35D03A2B5774AD2B9527BF371D27726" alt="image"></p><p><strong>Demo的工程结构</strong></p><p><img src="https://note.youdao.com/yws/public/resource/ac9c41aee95655840b3bad0550c9d7ec/83CB4ACE1BF5464ABB2A30A1D8501FC9" alt="image"></p><h5 id="API"><a href="#API" class="headerlink" title="API"></a>API</h5><p><img src="https://note.youdao.com/yws/public/resource/ac9c41aee95655840b3bad0550c9d7ec/822529C48F0E4920BD03212376977FDF" alt="image"></p><p><code>UserService</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:user公共接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Bryce</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019/7/2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;UserAddress&gt; <span class="title">getUserAddressList</span><span class="params">(String userId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UserAddress</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:地址实体类,属性注释略</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Bryce</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019/7/2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAddress</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2371259649236189428L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userddress;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String phoneNum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="user-service-provider"><a href="#user-service-provider" class="headerlink" title="user-service-provider"></a>user-service-provider</h5><p><img src="https://note.youdao.com/yws/public/resource/ac9c41aee95655840b3bad0550c9d7ec/535BA380A38B4C9085B61ED77BD6BCCB" alt="image"><br><br><code>pom.xml</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;</span><br><span class="line">    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;</span><br><span class="line">    &lt;dubbo.version&gt;2.7.2&lt;/dubbo.version&gt;</span><br><span class="line">  &lt;/properties&gt;</span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;dubbo&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;</span><br><span class="line">      &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.duingold.dubbo.simple&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;api&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p><code>UserServiceImpl</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:具体实现类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Bryce</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019/7/2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title">getUserAddressList</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">        UserAddress address = <span class="keyword">new</span> UserAddress(<span class="number">12</span>, <span class="string">"四川广安"</span>, <span class="string">"ssdd1122"</span>, <span class="string">"123333333333"</span>, <span class="string">"MIC"</span>);</span><br><span class="line">        UserAddress address1 = <span class="keyword">new</span> UserAddress(<span class="number">13</span>, <span class="string">"四川成都"</span>, <span class="string">"ssdd1123"</span>, <span class="string">"123333333335"</span>, <span class="string">"TOM"</span>);</span><br><span class="line">        UserAddress address2 = <span class="keyword">new</span> UserAddress(<span class="number">13</span>, <span class="string">"四川成都"</span>, <span class="string">"ssdd1123"</span>, <span class="string">"123333333337"</span>, <span class="string">"JAMES"</span>);</span><br><span class="line">        List&lt;UserAddress&gt; userAddressList = Arrays.asList(address, address1, address2);</span><br><span class="line">        <span class="keyword">return</span> userAddressList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>app启动类</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:provider.xml"</span>);</span><br><span class="line">        context.start();</span><br><span class="line">        System.in.read(); <span class="comment">// 按任意键退出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>provider.xml</code></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-4.3.xsd        http://dubbo.apache.org/schema/dubbo        http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"user-service-provider"</span>  /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用zookeeper广播注册中心暴露服务地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181?backup=127.0.0.1:2182,127.0.0.1:2183"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--2.7需要配置元数据和配置中心,不然dubbo-admin会有问题,出现找不到元数据--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:config-center</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181?backup=127.0.0.1:2182,127.0.0.1:2183"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:metadata-report</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181?backup=127.0.0.1:2182,127.0.0.1:2183"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 用dubbo协议在20880端口暴露服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 声明需要暴露的服务接口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.duingold.dubbo.simple.api.UserService"</span> <span class="attr">ref</span>=<span class="string">"userService"</span> <span class="attr">timeout</span>=<span class="string">"20000"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"getUserAddressList"</span> <span class="attr">timeout</span>=<span class="string">"30000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:monitor</span> <span class="attr">protocol</span>=<span class="string">"registry"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 和本地bean一样实现服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.duingold.dubbo.simple.impl.UserServiceImpl"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="user-service-consumer"><a href="#user-service-consumer" class="headerlink" title="user-service-consumer"></a>user-service-consumer</h5><p><img src="https://note.youdao.com/yws/public/resource/ac9c41aee95655840b3bad0550c9d7ec/B60044AD7DB44062B306C9313929D6A8" alt="image"><br></p><p><code>pom.xml</code>同上<br><br><code>OrderServices</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServices</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title">getAddress</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUserAddressList(userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>App启动类</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:consumer.xml"</span>);</span><br><span class="line">        OrderServices orderServices = (OrderServices) context.getBean(<span class="string">"orderServices"</span>);</span><br><span class="line">        List&lt;UserAddress&gt; address = orderServices.getAddress(<span class="string">"12"</span>);</span><br><span class="line">        address.forEach(System.out::println);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>consumer.xml</code></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span> <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-4.3.xsd        http://dubbo.apache.org/schema/dubbo        http://dubbo.apache.org/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.duingold.dubbo.simple.services"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"user-service-consumer"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用zookeeper广播注册中心暴露服务地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181?backup=127.0.0.1:2182,127.0.0.1:2183"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 生成远程服务代理，可以和本地bean一样使用userService --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--声明需要调用的远程服务的接口；生成远程服务代理  --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        1）、精确优先 (方法级优先，接口级次之，全局配置再次之)</span></span><br><span class="line"><span class="comment">        2）、消费者设置优先(如果级别一样，则消费方优先，提供方次之)</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- timeout="0" 默认是1000ms--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- retries="":重试次数，不包含第一次调用，0代表不重试--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 幂等（设置重试次数）【查询、删除、修改】、非幂等（不能设置重试次数）【新增】 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">interface</span>=<span class="string">"com.duingold.dubbo.simple.api.UserService"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span> <span class="attr">timeout</span>=<span class="string">"50000"</span> <span class="attr">retries</span>=<span class="string">"3"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 连接监控中心 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:monitor</span> <span class="attr">protocol</span>=<span class="string">"registry"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--&lt;bean id="orderServices" class="com.duingold.dubbo.simple.services.OrderServices"/&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h5><p>服务调用端:<br><img src="https://note.youdao.com/yws/public/resource/ac9c41aee95655840b3bad0550c9d7ec/1A21D4ED8CEB49A99F991BC46925D6D6" alt="image"><br><br>dubbo-admin控制台:<br><img src="https://note.youdao.com/yws/public/resource/ac9c41aee95655840b3bad0550c9d7ec/D52D099327694371BAB1C43907467BBA" alt="image"><br><img src="https://note.youdao.com/yws/public/resource/ac9c41aee95655840b3bad0550c9d7ec/18CE15B4526D410C8E39C343A09D7420" alt="image"><br><img src="https://note.youdao.com/yws/public/resource/ac9c41aee95655840b3bad0550c9d7ec/9386AE6500914F8A92770C88D53F5C43" alt="image"></p><p><a href="https://github.com/Duingold/codes/tree/master/dubbo/simple-demo" target="_blank" rel="noopener">本部分示例源码</a></p><h3 id="4-2-与springboot集成"><a href="#4-2-与springboot集成" class="headerlink" title="4.2 与springboot集成"></a>4.2 与springboot集成</h3><p><font color="red"><strong>注意</strong></font>:由于使用此时最新版<code>dubbo-spring-boot-starter</code>版本号<code>2.7.1</code>报错,改用老版本<code>dubbo-spring-boot-starter</code>版本号<code>0.2.1.RELEASE</code></p><h4 id="服务提供端"><a href="#服务提供端" class="headerlink" title="服务提供端"></a>服务提供端</h4><p><img src="https://note.youdao.com/yws/public/resource/ac9c41aee95655840b3bad0550c9d7ec/50BA6A56AB2C4955A9ED90083F45A869" alt="image"></p><p><code>pom.xml</code></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dubbo.version</span>&gt;</span>2.7.1<span class="tag">&lt;/<span class="name">dubbo.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.duingold.dubbo.simple<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>application.properties</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">dubbo.application.name=springboot-usersevice-provider</span><br><span class="line"></span><br><span class="line">dubbo.registry.protocol=zookeeper</span><br><span class="line"></span><br><span class="line">dubbo.registry.address=zookeeper://192.168.124.133:2181?backup=192.168.124.134:2181,192.168.124.135:2181</span><br><span class="line">#2.7需要配置元数据和配置中心,不然dubbo-admin会有问题,出现找不到元数据</span><br><span class="line">dubbo.config-center.protocol=zookeeper</span><br><span class="line">dubbo.config-center.address=zookeeper://192.168.124.133:2181?backup=192.168.124.134:2181,192.168.124.135:2181</span><br><span class="line">dubbo.metadata-report.address=zookeeper://192.168.124.133:2181?backup=192.168.124.134:2181,192.168.124.135:2181</span><br><span class="line">dubbo.monitor.protocol=registry</span><br><span class="line">#用dubbo协议在20880端口暴露服务</span><br><span class="line">dubbo.protocol.name=dubbo</span><br><span class="line">dubbo.protocol.port=20880</span><br><span class="line">#统一超时时间</span><br><span class="line">dubbo.provider.timeout=50000</span><br></pre></td></tr></table></figure><p>代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">启动类:</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDubbo</span> <span class="comment">//启动dubbo组件,并扫描包</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(ProviderApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dubbo注解</span></span><br><span class="line"><span class="meta">@Service</span>(version = <span class="string">"1.0.0"</span>,weight = <span class="number">50</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title">getUserAddressList</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">        UserAddress address = <span class="keyword">new</span> UserAddress(<span class="number">12</span>, <span class="string">"四川广安"</span>, <span class="string">"ssdd1122"</span>, <span class="string">"123333333333"</span>, <span class="string">"MIC"</span>);</span><br><span class="line">        UserAddress address1 = <span class="keyword">new</span> UserAddress(<span class="number">13</span>, <span class="string">"四川成都"</span>, <span class="string">"ssdd1123"</span>, <span class="string">"123333333335"</span>, <span class="string">"TOM"</span>);</span><br><span class="line">        UserAddress address2 = <span class="keyword">new</span> UserAddress(<span class="number">13</span>, <span class="string">"四川成都"</span>, <span class="string">"ssdd1123"</span>, <span class="string">"123333333337"</span>, <span class="string">"JAMES"</span>);</span><br><span class="line">        List&lt;UserAddress&gt; userAddressList = Arrays.asList(address, address1, address2);</span><br><span class="line">        <span class="keyword">return</span> userAddressList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="服务调用端"><a href="#服务调用端" class="headerlink" title="服务调用端"></a>服务调用端</h4><p><img src="https://note.youdao.com/yws/public/resource/ac9c41aee95655840b3bad0550c9d7ec/14DE9B5B4D134FA6B81E5ABC983E6D27" alt="image"><br><br><code>pom.xml</code>同服务提供端</p><p><code>application.properties</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server.port=9090</span><br><span class="line"></span><br><span class="line">dubbo.application.name=springboot-usersevice-consumer</span><br><span class="line"></span><br><span class="line">dubbo.registry.protocol=zookeeper</span><br><span class="line"></span><br><span class="line">dubbo.registry.address=zookeeper://192.168.124.133:2181?backup=192.168.124.134:2181,192.168.124.135:2181</span><br><span class="line"></span><br><span class="line">dubbo.monitor.protocol=registry</span><br><span class="line"></span><br><span class="line">#统一超时时间</span><br><span class="line">dubbo.consumer.timeout=50000</span><br><span class="line">#关闭所有服务的启动时检查 </span><br><span class="line">dubbo.consumer.check=false</span><br></pre></td></tr></table></figure><p>代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">启动类:</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDubbo</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(ConsumerApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServices</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * version:版本号,timeout:超时时间,loadbalance:负载均衡策略,retries:失败重试次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Reference</span>(version = <span class="string">"1.0.0"</span>,timeout = <span class="number">3000</span>,loadbalance =<span class="string">"random"</span>,retries = <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title">getAddress</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUserAddressList(userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderServices orderServices;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/address/&#123;userId&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title">getUserAddressList</span> <span class="params">(@PathVariable(<span class="string">"userId"</span>)</span> String userId)</span>&#123;</span><br><span class="line">        System.out.println(userId);</span><br><span class="line">        <span class="keyword">return</span> orderServices.getAddress(userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>启动服务提供方和服务调用方,并访问<code>http://localhost:9090/user/address/*</code></p><p><img src="https://note.youdao.com/yws/public/resource/ac9c41aee95655840b3bad0550c9d7ec/1675255D88804B6E99980CB2F4C7A566" alt="image"></p><h3 id="4-3-dubbo常用配置"><a href="#4-3-dubbo常用配置" class="headerlink" title="4.3 dubbo常用配置"></a>4.3 dubbo常用配置</h3><blockquote><p>参考:<a href="http://dubbo.apache.org/zh-cn/docs/user/configuration/configuration-load-process.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/user/configuration/configuration-load-process.html</a></p></blockquote><h4 id="配置原则"><a href="#配置原则" class="headerlink" title="配置原则"></a>配置原则</h4><p>首先，从Dubbo支持的配置来源说起，默认有四种配置来源：</p><ul><li>JVM System Properties，-D参数</li><li>Externalized Configuration，外部化配置</li><li>ServiceConfig、ReferenceConfig等编程接口采集的配置</li><li>本地配置文件dubbo.properties</li></ul><p>下图展示了配置覆盖关系的优先级，从上到下优先级依次降低：<br><br><img src="https://note.youdao.com/yws/public/resource/ac9c41aee95655840b3bad0550c9d7ec/2433B94BEC2A418CB06197AED778F6AD" alt="image"></p><h4 id="集群容错"><a href="#集群容错" class="headerlink" title="集群容错"></a>集群容错</h4><blockquote><p>参考:<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/fault-tolerent-strategy.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/user/demos/fault-tolerent-strategy.html</a></p></blockquote><p>在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。</p><ul><li>Failover Cluster</li></ul><p>失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=”2” 来设置重试次数(不含第一次)。</p><p>重试次数配置如下：</p><pre><code>&lt;dubbo:service retries=&quot;2&quot; /&gt;</code></pre><p>或</p><pre><code>&lt;dubbo:reference retries=&quot;2&quot; /&gt;</code></pre><p>或</p><pre><code>&lt;dubbo:reference&gt;    &lt;dubbo:method name=&quot;findFoo&quot; retries=&quot;2&quot; /&gt;&lt;/dubbo:reference&gt;</code></pre><ul><li>Failfast Cluster</li></ul><p>快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</p><ul><li>Failsafe Cluster</li></ul><p>失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</p><ul><li>Failback Cluster</li></ul><p>失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</p><ul><li>Forking Cluster</li></ul><p>并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=”2” 来设置最大并行数。</p><ul><li>Broadcast Cluster</li></ul><p>广播调用所有提供者，逐个调用，任意一台报错则报错 [2]。通常用于通知所有提供者更新缓存或日志等本地资源信息。</p><p>集群模式配置</p><p>按照以下示例在服务提供方和消费方配置集群模式</p><pre><code>&lt;dubbo:service cluster=&quot;failsafe&quot; /&gt;</code></pre><p>或</p><pre><code>&lt;dubbo:reference cluster=&quot;failsafe&quot; /&gt;</code></pre><h4 id="超时时间"><a href="#超时时间" class="headerlink" title="超时时间"></a>超时时间</h4><p>由于网络或服务端不可靠，会导致调用出现一种不确定的中间状态（超时）。为了避免超时导致客户端资源（线程）挂起耗尽，必须设置超时时间</p><h5 id="Dubbo消费端"><a href="#Dubbo消费端" class="headerlink" title="Dubbo消费端"></a>Dubbo消费端</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">全局超时配置</span><br><span class="line">&lt;dubbo:consumer timeout=&quot;5000&quot; /&gt;</span><br><span class="line"></span><br><span class="line">指定接口以及特定方法超时配置</span><br><span class="line">&lt;dubbo:reference interface=&quot;com.foo.BarService&quot; timeout=&quot;2000&quot;&gt;</span><br><span class="line">    &lt;dubbo:method name=&quot;sayHello&quot; timeout=&quot;3000&quot; /&gt;</span><br><span class="line">&lt;/dubbo:reference&gt;</span><br></pre></td></tr></table></figure><h5 id="Dubbo服务端"><a href="#Dubbo服务端" class="headerlink" title="Dubbo服务端"></a>Dubbo服务端</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">全局超时配置</span><br><span class="line">&lt;dubbo:provider timeout=&quot;5000&quot; /&gt;</span><br><span class="line"></span><br><span class="line">指定接口以及特定方法超时配置</span><br><span class="line">&lt;dubbo:provider interface=&quot;com.foo.BarService&quot; timeout=&quot;2000&quot;&gt;</span><br><span class="line">    &lt;dubbo:method name=&quot;sayHello&quot; timeout=&quot;3000&quot; /&gt;</span><br><span class="line">&lt;/dubbo:provider&gt;</span><br></pre></td></tr></table></figure><h5 id="配置原则-1"><a href="#配置原则-1" class="headerlink" title="配置原则"></a>配置原则</h5><p>dubbo推荐在Provider上尽量多配置Consumer端属性</p><pre><code>1、作服务的提供者，比服务使用方更清楚服务性能参数，如调用的超时时间，合理的重试次数，等等2、在Provider配置后，Consumer不配置则会使用Provider的配置值，即Provider配置可以作为Consumer的缺省值。否则，Consumer会使用Consumer端的全局设置，这对于Provider不可控的，并且往往是不合理的</code></pre><p>配置的覆盖规则：<br>1) 方法级配置别优于接口级别，即小Scope优先<br>2) Consumer端配置 优于 Provider配置 优于 全局配置，<br>3) 最后是Dubbo Hard Code的配置值（见配置文档）</p><p><img src="https://note.youdao.com/yws/public/resource/ac9c41aee95655840b3bad0550c9d7ec/12537F3DCA834FAB864CAA449C163F0B" alt="image"></p><h4 id="版本号-灰度发布"><a href="#版本号-灰度发布" class="headerlink" title="版本号(灰度发布)"></a>版本号(灰度发布)</h4><p>当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。</p><p>可以按照以下的步骤进行版本迁移：</p><ol><li>在低压力时间段，先升级一半提供者为新版本</li><li>再将所有消费者升级为新版本</li><li>然后将剩下的一半提供者升级为新版本</li></ol><p>老版本服务提供者配置：</p><pre><code>&lt;dubbo:service interface=&quot;com.foo.BarService&quot; version=&quot;1.0.0&quot; /&gt;</code></pre><p>新版本服务提供者配置：</p><pre><code>&lt;dubbo:service interface=&quot;com.foo.BarService&quot; version=&quot;2.0.0&quot; /&gt;</code></pre><p>老版本服务消费者配置：</p><pre><code>&lt;dubbo:reference id=&quot;barService&quot; interface=&quot;com.foo.BarService&quot; version=&quot;1.0.0&quot; /&gt;</code></pre><p>新版本服务消费者配置：</p><pre><code>&lt;dubbo:reference id=&quot;barService&quot; interface=&quot;com.foo.BarService&quot; version=&quot;2.0.0&quot; /&gt;</code></pre><p>如果不需要区分版本，可以按照以下的方式配置:</p><pre><code>&lt;dubbo:reference id=&quot;barService&quot; interface=&quot;com.foo.BarService&quot; version=&quot;*&quot; /&gt;</code></pre><h3 id="4-4-高可用"><a href="#4-4-高可用" class="headerlink" title="4.4 高可用"></a>4.4 高可用</h3><h4 id="4-4-1-zookeeper宕机与dubbo直连"><a href="#4-4-1-zookeeper宕机与dubbo直连" class="headerlink" title="4.4.1 zookeeper宕机与dubbo直连"></a>4.4.1 zookeeper宕机与dubbo直连</h4><p>现象：zookeeper注册中心宕机，还可以消费dubbo暴露的服务。</p><p>原因：</p><pre><code>健壮性监控中心宕掉不影响使用，只是丢失部分采样数据数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务注册中心对等集群，任意一台宕掉后，将自动切换到另一台注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯服务提供者无状态，任意一台宕掉后，不影响使用服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</code></pre><h4 id="4-4-2-负载均衡"><a href="#4-4-2-负载均衡" class="headerlink" title="4.4.2 负载均衡"></a>4.4.2 负载均衡</h4><p>在集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 random 随机调用。</p><h5 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h5><h6 id="Random-LoadBalance"><a href="#Random-LoadBalance" class="headerlink" title="Random LoadBalance"></a>Random LoadBalance</h6><ul><li><strong>随机</strong>，按权重设置随机概率。</li><li>在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。<h6 id="RoundRobin-LoadBalance"><a href="#RoundRobin-LoadBalance" class="headerlink" title="RoundRobin LoadBalance"></a>RoundRobin LoadBalance</h6></li><li><strong>轮询</strong>，按公约后的权重设置轮询比率。</li><li>存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。<h6 id="LeastActive-LoadBalance"><a href="#LeastActive-LoadBalance" class="headerlink" title="LeastActive LoadBalance"></a>LeastActive LoadBalance</h6></li><li><strong>最少活跃调用数</strong>，相同活跃数的随机，活跃数指调用前后计数差。</li><li>使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。<h6 id="ConsistentHash-LoadBalance"><a href="#ConsistentHash-LoadBalance" class="headerlink" title="ConsistentHash LoadBalance"></a>ConsistentHash LoadBalance</h6></li><li><strong>一致性 Hash</strong>，相同参数的请求总是发到同一提供者。</li><li>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</li><li>算法参见：<a href="http://en.wikipedia.org/wiki/Consistent_hashing" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Consistent_hashing</a></li><li>缺省只对第一个参数 Hash，如果要修改，请配置 &lt;dubbo:parameter key=”hash.arguments” value=”0,1” /&gt;</li><li>缺省用 160 份虚拟节点，如果要修改，请配置 &lt;dubbo:parameter key=”hash.nodes” value=”320” /&gt;</li></ul><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>服务端服务级别</p><pre><code>&lt;dubbo:service interface=&quot;...&quot; loadbalance=&quot;roundrobin&quot; /&gt;</code></pre><p>客户端服务级别</p><pre><code>&lt;dubbo:reference interface=&quot;...&quot; loadbalance=&quot;roundrobin&quot; /&gt;</code></pre><p>服务端方法级别</p><pre><code>&lt;dubbo:service interface=&quot;...&quot;&gt;    &lt;dubbo:method name=&quot;...&quot; loadbalance=&quot;roundrobin&quot;/&gt;&lt;/dubbo:service&gt;</code></pre><p>客户端方法级别</p><pre><code>&lt;dubbo:reference interface=&quot;...&quot;&gt;    &lt;dubbo:method name=&quot;...&quot; loadbalance=&quot;roundrobin&quot;/&gt;&lt;/dubbo:reference&gt;</code></pre><h3 id="4-5-整合hystrix，服务熔断与降级处理"><a href="#4-5-整合hystrix，服务熔断与降级处理" class="headerlink" title="4.5 整合hystrix，服务熔断与降级处理"></a>4.5 整合hystrix，服务熔断与降级处理</h3><h4 id="4-5-1服务降级"><a href="#4-5-1服务降级" class="headerlink" title="4.5.1服务降级"></a>4.5.1服务降级</h4><h5 id="什么是服务降级？"><a href="#什么是服务降级？" class="headerlink" title="什么是服务降级？"></a>什么是服务降级？</h5><p>当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作。</p><p>可以通过服务降级功能临时屏蔽某个出错的非关键服务，并定义降级后的返回策略。</p><h6 id="通过dubbo-admin管理页面进行服务降级"><a href="#通过dubbo-admin管理页面进行服务降级" class="headerlink" title="通过dubbo-admin管理页面进行服务降级"></a>通过<code>dubbo-admin</code>管理页面进行服务降级</h6><p>可在<code>dubbo-admin</code>中进行配置,因为此处的版本为<code>2.7</code>功能并不完善,没有做演示,可以使用老版本(<code>2.6</code>及以下)的<code>dubbo-admin</code>进行操作如下:<br><img src="https://note.youdao.com/yws/public/resource/ac9c41aee95655840b3bad0550c9d7ec/93A238010545432392D1F5533C68C285" alt="image"><br><img src="https://note.youdao.com/yws/public/resource/ac9c41aee95655840b3bad0550c9d7ec/FC9B7A140CBD47BA95B6EEB886645E13" alt="image"><br><img src="https://note.youdao.com/yws/public/resource/ac9c41aee95655840b3bad0550c9d7ec/EC709FD0D39A40889FA113D28FDA1439" alt="image"></p><h6 id="通过配置进行服务降级"><a href="#通过配置进行服务降级" class="headerlink" title="通过配置进行服务降级"></a>通过配置进行服务降级</h6><p>dubbo自身是支持mock服务的，在reference标签里，有一个参数mock，该参数有四个值，false,default,true,或者Mock类的类名。分别代表如下含义:</p><ul><li>false，不调用mock服务。</li><li>true，当服务调用失败时，使用mock服务。</li><li>default，当服务调用失败时，使用mock服务。</li><li>force，强制使用Mock服务(不管服务能否调用成功)。(使用xml配置不生效,使用ReferenceConfigAPI可以生效)</li></ul><p><strong>使用方式一:</strong><br><br>我们调用接口失败的时候，可以通过 mock 统一返回 null。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:reference id=&quot;userService&quot; interface=&quot;com.duingold.dubbo.simple.api.UserService&quot; version=&quot;1.0.0&quot; timeout=&quot;50000&quot; retries=&quot;3&quot; mock=&quot;return null&quot;/&gt;</span><br></pre></td></tr></table></figure><p><strong>使用方式二:</strong><br><br>mock 的值也可以修改为 true，然后再跟接口同一个路径下实现一个 Mock 类，命名规则是 <code>接口名称+Mock</code> 后缀。然后在 Mock 类里实现自己的降级逻辑。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;dubbo:reference id=&quot;userService&quot; interface=&quot;com.duingold.dubbo.simple.api.UserService&quot; version=&quot;1.0.0&quot; timeout=&quot;50000&quot; retries=&quot;3&quot; mock=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceMock</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title">getUserAddressList</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 降级逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-2整合hystrix进行服务容错和降级"><a href="#4-5-2整合hystrix进行服务容错和降级" class="headerlink" title="4.5.2整合hystrix进行服务容错和降级"></a>4.5.2整合hystrix进行服务容错和降级</h4><p>Hystrix 旨在通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备拥有回退机制和断路器功能的线程和信号隔离，请求缓存和请求打包，以及监控和配置等功能</p><h5 id="配置spring-cloud-starter-netflix-hystrix"><a href="#配置spring-cloud-starter-netflix-hystrix" class="headerlink" title="配置spring-cloud-starter-netflix-hystrix"></a>配置spring-cloud-starter-netflix-hystrix</h5><p>spring boot官方提供了对hystrix的集成，直接在pom.xml里加入依赖：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.4.4.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>然后在Application类上增加@EnableHystrix来启用hystrix starter：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableHystrix</span><br><span class="line">public class ProviderApplication &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="配置Provider端"><a href="#配置Provider端" class="headerlink" title="配置Provider端"></a>配置Provider端</h5><p>在Dubbo的Provider上增加@HystrixCommand配置，这样子调用就会经过Hystrix代理。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service(version = &quot;1.0.0&quot;)</span><br><span class="line">public class HelloServiceImpl implements HelloService &#123;</span><br><span class="line">    @HystrixCommand(commandProperties = &#123;</span><br><span class="line">     @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;, value = &quot;10&quot;),</span><br><span class="line">     @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;2000&quot;) &#125;)</span><br><span class="line">    @Override</span><br><span class="line">    public String sayHello(String name) &#123;</span><br><span class="line">        // System.out.println(&quot;async provider received: &quot; + name);</span><br><span class="line">        // return &quot;annotation: hello, &quot; + name;</span><br><span class="line">        throw new RuntimeException(&quot;Exception to show hystrix enabled.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="配置Consumer端"><a href="#配置Consumer端" class="headerlink" title="配置Consumer端"></a>配置Consumer端</h5><p>对于Consumer端，则可以增加一层method调用，并在method上配置@HystrixCommand。当调用出错时，会走到fallbackMethod = “reliable”的调用里。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Reference(version = &quot;1.0.0&quot;)</span><br><span class="line">    private HelloService demoService;</span><br><span class="line"></span><br><span class="line">    @HystrixCommand(fallbackMethod = &quot;reliable&quot;)</span><br><span class="line">    public String doSayHello(String name) &#123;</span><br><span class="line">        return demoService.sayHello(name);</span><br><span class="line">    &#125;</span><br><span class="line">    public String reliable(String name) &#123;</span><br><span class="line">        return &quot;hystrix fallback value&quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/Duingold/codes/tree/master/dubbo/simple-demo/springboot-dubbo-simple" target="_blank" rel="noopener">本部分示例代码</a></p><h2 id="基本原理-简单介绍"><a href="#基本原理-简单介绍" class="headerlink" title="基本原理(简单介绍)"></a>基本原理(简单介绍)</h2><p><strong>这里只是大概介绍其原理,详细介绍会在<code>Dubbo源码分析.md</code>里面进行分析</strong></p><h3 id="dubbo原理-框架设计"><a href="#dubbo原理-框架设计" class="headerlink" title="dubbo原理-框架设计"></a>dubbo原理-框架设计</h3><p><img src="https://note.youdao.com/yws/public/resource/ac9c41aee95655840b3bad0550c9d7ec/A2FF1830405848598947287C11FF2E0B" alt="image"></p><ul><li>config 配置层：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类</li><li>proxy 服务代理层：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory</li><li>registry 注册中心层：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService</li><li>cluster 路由层：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance</li><li>monitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService</li><li>protocol 远程调用层：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter</li><li>exchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer</li><li>transport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec</li><li>serialize 数据序列化层：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool</li></ul><h3 id="dubbo原理-启动解析、加载配置信息"><a href="#dubbo原理-启动解析、加载配置信息" class="headerlink" title="dubbo原理-启动解析、加载配置信息"></a>dubbo原理-启动解析、加载配置信息</h3><p><img src="https://note.youdao.com/yws/public/resource/ac9c41aee95655840b3bad0550c9d7ec/D9F6148715BE4D988258E3193A0FB515" alt="image"></p><h3 id="dubbo原理-服务暴露"><a href="#dubbo原理-服务暴露" class="headerlink" title="dubbo原理-服务暴露"></a>dubbo原理-服务暴露</h3><p><img src="https://note.youdao.com/yws/public/resource/ac9c41aee95655840b3bad0550c9d7ec/06DE31B839BB45FC97A8F3B4498C3336" alt="image"></p><h3 id="dubbo原理-服务引用"><a href="#dubbo原理-服务引用" class="headerlink" title="dubbo原理-服务引用"></a>dubbo原理-服务引用</h3><p><img src="https://note.youdao.com/yws/public/resource/ac9c41aee95655840b3bad0550c9d7ec/A16CFCAEB2A544FBBE5A8FD38C9C8A0D" alt="image"></p><h3 id="dubbo原理-服务调用"><a href="#dubbo原理-服务调用" class="headerlink" title="dubbo原理-服务调用"></a>dubbo原理-服务调用</h3><p><img src="https://note.youdao.com/yws/public/resource/ac9c41aee95655840b3bad0550c9d7ec/E20092BF482943F59A416A6E52085BB7" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三大性质总结：原子性，有序性，可见性</title>
      <link href="/2019/07/14/%E4%B8%89%E5%A4%A7%E6%80%A7%E8%B4%A8%E6%80%BB%E7%BB%93%EF%BC%9A%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%8C%E6%9C%89%E5%BA%8F%E6%80%A7%EF%BC%8C%E5%8F%AF%E8%A7%81%E6%80%A7/"/>
      <url>/2019/07/14/%E4%B8%89%E5%A4%A7%E6%80%A7%E8%B4%A8%E6%80%BB%E7%BB%93%EF%BC%9A%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%8C%E6%9C%89%E5%BA%8F%E6%80%A7%EF%BC%8C%E5%8F%AF%E8%A7%81%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a><div id="Inter-Page">原子性</div></h4><p>原子性是指一个操作是不可中断的，要么全部执行成功要么全部执行失败，有着“同生共死”的感觉。及时在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰。我们先来看看哪些是原子操作，哪些不是原子操作，有一个直观的印象：</p><pre><code>int a = 10;  //1a++;  //2int b=a; //3a = a+1; //4</code></pre><p>上面这四个语句中只有<strong>第1个语句是原子操作</strong>，将10赋值给线程工作内存的变量a,而语句2（a++），实际上包含了三个操作：1. 读取变量a的值；2：对a进行加一的操作；3.将计算后的值再赋值给变量a，而这三个操作无法构成原子操作。对语句3,4的分析同理可得这两条语句不具备原子性。当然，java内存模型中定义了8中操作都是原子的，不可再分的。</p><ol><li>lock(锁定)：作用于主内存中的变量，它把一个变量标识为一个线程独占的状态；</li><li>unlock(解锁):作用于主内存中的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li><li>read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便后面的load动作使用；</li><li>load（载入）：作用于工作内存中的变量，它把read操作从主内存中得到的变量值放入工作内存中的变量副本</li><li>use（使用）：作用于工作内存中的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作；</li><li>assign（赋值）：作用于工作内存中的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作；</li><li>store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送给主内存中以便随后的write操作使用；</li><li>write（操作）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li></ol><p>上面的这些指令操作是相当底层的，可以作为扩展知识面掌握下。那么如何理解这些指令了?比如，把一个变量从主内存中复制到工作内存中就需要执行read,load操作，将工作内存同步到主内存中就需要执行store,write操作。注意的是：<strong>java内存模型只是要求上述两个操作是顺序执行的并不是连续执行的。</strong>也就是说read和load之间可以插入其他指令，store和writer可以插入其他指令。比如对主内存中的a,b进行访问就可以出现这样的操作顺序：<strong>read a,read b, load b,load a。</strong><br>由原子性变量操作read,load,use,assign,store,write，可以大致认为基本数据类型的访问读写具备原子性（例外就是long和double的非原子性协定）</p><pre><code>synchronized</code></pre><p>上面一共有八条原子操作，其中六条可以满足基本数据类型的访问读写具备原子性，还剩下lock和unlock两条原子操作。如果我们需要更大范围的原子性操作就可以使用lock和unlock原子操作。尽管jvm没有把lock和unlock开放给我们使用，但jvm以更高层次的指令monitorenter和monitorexit指令开放给我们使用，反应到java代码中就是—synchronized关键字，<strong>也就是说synchronized满足原子性。</strong></p><pre><code>volatile</code></pre><p>我们先来看这样一个例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">                        counter++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(counter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启10个线程，每个线程都自加10000次，如果不出现线程安全的问题最终的结果应该就是：10<em>10000 = 100000;可是运行多次都是小于100000的结果，问题在于 *</em>volatile并不能保证原子性**，在前面说过counter++这并不是一个原子操作，包含了三个步骤：1.读取变量counter的值；2.对counter加一；3.将新值赋值给变量counter。如果线程A读取counter到工作内存后，其他线程对这个值已经做了自增操作后，那么线程A的这个值自然而然就是一个过期的值，因此，总结果必然会是小于100000的。<br>如果让volatile保证原子性，必须符合以下两条规则：</p><p><strong>1.运算结果并不依赖于变量的当前值，或者能够确保只有一个线程修改变量的值；</strong></p><p><strong>2.变量不需要与其他的状态变量共同参与不变约束</strong></p><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><pre><code>synchronized</code></pre><p>synchronized语义表示锁在同一时刻只能由一个线程进行获取，当锁被占用后，其他线程只能等待。因此，synchronized语义就要求线程在访问读写共享变量时只能“串行”执行，因此<strong>synchronized具有有序性。</strong></p><pre><code>volatile</code></pre><p>在java内存模型中说过，为了性能优化，编译器和处理器会进行指令重排序；也就是说java程序天然的有序性可以总结为：如果在本线程内观察，所有的操作都是有序的；如果在一个线程观察另一个线程，所有的操作都是无序的。在单例模式的实现上有一种双重检验锁定的方式（Double-checked Locking）。代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里为什么要加volatile了？我们先来分析一下不加volatile的情况，有问题的语句是这条：</p><pre><code>instance = new Singleton();</code></pre><p>这条语句实际上包含了三个操作：1.分配对象的内存空间；2.初始化对象；3.设置instance指向刚分配的内存地址。但由于存在重排序的问题，可能有以下的执行顺序：<br><img src="https://note.youdao.com/yws/public/resource/36dd820c4ac0d07228b10e2347e6a31b/D4FF5675034B46529839F1237BE18562?ynotemdtimestamp=1563101549393" alt="image"></p><p>如果2和3进行了重排序的话，线程B进行判断if(instance==null)时就会为true，而实际上这个instance并没有初始化成功，显而易见对线程B来说之后的操作就会是错得。而用volatile修饰的话就可以禁止2和3操作重排序，从而避免这种情况。<strong>volatile包含禁止指令重排序的语义，其具有有序性。</strong></p><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>可见性是指当一个线程修改了共享变量后，其他线程能够立即得知这个修改。通过之前对synchronzed内存语义进行了分析，当线程获取锁时会从主内存中获取共享变量的最新值，释放锁的时候会将共享变量同步到主内存中。从而，s<strong>ynchronized具有可见性</strong>。同样的在volatile分析中，会通过在指令中添加lock指令，以实现内存可见性。因此, <strong>volatile具有可见性</strong></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通过这篇文章，主要是比较了synchronized和volatile在三条性质：原子性，可见性，以及有序性的情况，归纳如下：</p><pre><code>synchronized: 具有原子性，有序性和可见性；volatile：具有有序性和可见性</code></pre>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原子性 </tag>
            
            <tag> 有序性 </tag>
            
            <tag> 可见性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集群部署时的分布式 session 如何实现？</title>
      <link href="/2019/07/14/%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%E6%97%B6%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F-session-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F/"/>
      <url>/2019/07/14/%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%E6%97%B6%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F-session-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文:<a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/distributed-session.md" target="_blank" rel="noopener">https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/distributed-session.md</a></p></blockquote><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>集群部署时的分布式 session 如何实现？</p><h2 id="面试官心理分析"><a href="#面试官心理分析" class="headerlink" title="面试官心理分析"></a>面试官心理分析</h2><p>面试官问了你一堆 dubbo 是怎么玩儿的，你会玩儿 dubbo 就可以把单块系统弄成分布式系统，然后分布式之后接踵而来的就是一堆问题，最大的问题就是<strong>分布式事务</strong>、<strong>接口幂等性</strong>、<strong>分布式锁</strong>，还有最后一个就是<strong>分布式 session</strong>。</p><p>当然了，分布式系统中的问题何止这么一点，非常之多，复杂度很高，这里只是说一下常见的几个问题，也是面试的时候常问的几个。</p><h2 id="面试题剖析"><a href="#面试题剖析" class="headerlink" title="面试题剖析"></a>面试题剖析</h2><p>session 是啥？浏览器有个 cookie，在一段时间内这个 cookie 都存在，然后每次发请求过来都带上一个特殊的 <code>jsessionid cookie</code>，就根据这个东西，在服务端可以维护一个对应的 session 域，里面可以放点数据。</p><p>一般的话只要你没关掉浏览器，cookie 还在，那么对应的那个 session 就在，但是如果 cookie 没了，session 也就没了。常见于什么购物车之类的东西，还有登录状态保存之类的。</p><p>这个不多说了，懂 Java 的都该知道这个。</p><p>单块系统的时候这么玩儿 session 没问题，但是你要是分布式系统呢，那么多的服务，session 状态在哪儿维护啊？</p><p>其实方法很多，但是常见常用的是以下几种：</p><h3 id="完全不用-session"><a href="#完全不用-session" class="headerlink" title="完全不用 session"></a>完全不用 session</h3><p>使用 JWT Token 储存用户身份，然后再从数据库或者 cache 中获取其他的信息。这样无论请求分配到哪个服务器都无所谓。</p><h3 id="tomcat-redis"><a href="#tomcat-redis" class="headerlink" title="tomcat + redis"></a>tomcat + redis</h3><p>这个其实还挺方便的，就是使用 session 的代码，跟以前一样，还是基于 tomcat 原生的 session 支持即可，然后就是用一个叫做 <code>Tomcat  RedisSessionManager</code> 的东西，让所有我们部署的 tomcat 都将 session 数据存储到 redis 即可。</p><p>在 tomcat 的配置文件中配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Manager</span> <span class="attr">className</span>=<span class="string">"com.orangefunction.tomcat.redissessions.RedisSessionManager"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">host</span>=<span class="string">"&#123;redis.host&#125;"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">port</span>=<span class="string">"&#123;redis.port&#125;"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">database</span>=<span class="string">"&#123;redis.dbnum&#125;"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">maxInactiveInterval</span>=<span class="string">"60"</span>/&gt;</span></span><br><span class="line">```         </span><br><span class="line"></span><br><span class="line">然后指定 redis 的 host 和 port 就 ok 了。</span><br><span class="line"></span><br><span class="line">```xml</span><br><span class="line"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Manager</span> <span class="attr">className</span>=<span class="string">"com.orangefunction.tomcat.redissessions.RedisSessionManager"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">sentinelMaster</span>=<span class="string">"mymaster"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">sentinels</span>=<span class="string">"&lt;sentinel1-ip&gt;:26379,&lt;sentinel2-ip&gt;:26379,&lt;sentinel3-ip&gt;:26379"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">maxInactiveInterval</span>=<span class="string">"60"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>还可以用上面这种方式基于 redis 哨兵支持的 redis 高可用集群来保存 session 数据，都是 ok 的。</p><h3 id="spring-session-redis"><a href="#spring-session-redis" class="headerlink" title="spring session + redis"></a>spring session + redis</h3><p>上面所说的第二种方式会与 tomcat 容器重耦合，如果我要将 web 容器迁移成 jetty，难道还要重新把 jetty 都配置一遍？</p><p>因为上面那种 tomcat + redis 的方式好用，但是会<strong>严重依赖于web容器</strong>，不好将代码移植到其他 web 容器上去，尤其是你要是换了技术栈咋整？比如换成了 spring cloud 或者是 spring boot 之类的呢？</p><p>所以现在比较好的还是基于 Java 一站式解决方案，也就是 spring。人家 spring 基本上承包了大部分我们需要使用的框架，spirng cloud 做微服务，spring boot 做脚手架，所以用 sping session 是一个很好的选择。</p><p>在 pom.xml 中配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 spring 配置文件中配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"redisHttpSessionConfiguration"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">class</span>=<span class="string">"org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxInactiveIntervalInSeconds"</span> <span class="attr">value</span>=<span class="string">"600"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jedisPoolConfig"</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.JedisPoolConfig"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxTotal"</span> <span class="attr">value</span>=<span class="string">"100"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdle"</span> <span class="attr">value</span>=<span class="string">"10"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jedisConnectionFactory"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.connection.jedis.JedisConnectionFactory"</span> <span class="attr">destroy-method</span>=<span class="string">"destroy"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hostName"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis_hostname&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"port"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis_port&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis_pwd&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeout"</span> <span class="attr">value</span>=<span class="string">"3000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"usePool"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"poolConfig"</span> <span class="attr">ref</span>=<span class="string">"jedisPoolConfig"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 web.xml 中配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSessionRepositoryFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSessionRepositoryFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/putIntoSession"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">putIntoSession</span><span class="params">(HttpServletRequest request, String username)</span> </span>&#123;</span><br><span class="line">        request.getSession().setAttribute(<span class="string">"name"</span>,  <span class="string">"leo"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ok"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/getFromSession"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFromSession</span><span class="params">(HttpServletRequest request, Model model)</span></span>&#123;</span><br><span class="line">        String name = request.getSession().getAttribute(<span class="string">"name"</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就是 ok 的，给 sping session 配置基于 redis 来存储 session 数据，然后配置了一个 spring session 的过滤器，这样的话，session 相关操作都会交给 spring session 来管了。接着在代码中，就用原生的 session 操作，就是直接基于 spring sesion 从 redis 中获取数据了。</p><p>实现分布式的会话有很多种方式，我说的只不过是比较常见的几种方式，tomcat + redis 早期比较常用，但是会重耦合到 tomcat 中；近些年，通过 spring session 来实现。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> session </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池原理分析</title>
      <link href="/2019/07/12/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
      <url>/2019/07/12/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><pre><code>在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程</code></pre><p><strong>使用线程池的好处:</strong></p><pre><code>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。 第三：提高线程的可管理性。 </code></pre><p>java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。 </p><p>比较重要的几个类：</p><table><thead><tr><th>类/接口</th><th>说明</th></tr></thead><tbody><tr><td>ExecutorService</td><td>真正的线程池接口。</td></tr><tr><td>ScheduledExecutorService</td><td>和Timer/TimerTask类似，解决那些需要任务重复执行的问题。</td></tr><tr><td>ThreadPoolExecutor</td><td>ExecutorService的默认实现。</td></tr><tr><td>ScheduledThreadPoolExecutor</td><td>继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现。</td></tr><tr><td>#### 执行流程</td><td></td></tr><tr><td>当一个任务通过execute(Runnable)方法欲添加到线程池时：</td><td></td></tr></tbody></table><ol><li>如果此时线程池中的数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的核心线程来处理被添加的任务。</li><li>如果此时线程池中的数量等于 corePoolSize，但是缓冲队列 workQueue未满，那么任务被放入缓冲队列。</li><li>如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于maximumPoolSize，建新的普通线程来处理被添加的任务。</li><li>如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等于maximumPoolSize，那么通过 handler所指定的策略来处理此任务。也就是：处理任务的优先级为：核心线程corePoolSize、任务队列workQueue、最大线程 maximumPoolSize，如果三者都满了，使用handler处理被拒绝的任务。</li><li>当线程池中的线程数量大于corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数。</li></ol><h5 id="流程图"><a href="#流程图" class="headerlink" title="流程图:"></a>流程图:</h5><p><img src="/2019/07/12/线程池原理分析/1562947256010.png" alt="1562947256010"></p><h4 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h4><h5 id="通过ThreadPoolExecutor创建"><a href="#通过ThreadPoolExecutor创建" class="headerlink" title="通过ThreadPoolExecutor创建"></a>通过ThreadPoolExecutor创建</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                              <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                              <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory,</span><br><span class="line">                              RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure><pre><code>corePoolSize: 线程池维护线程的最少线程数,也是核心线程数,包括空闲线程maximumPoolSize: 线程池维护线程的最大线程数keepAliveTime: 线程池维护线程所允许的空闲时间unit: 程池维护线程所允许的空闲时间的单位workQueue: 线程池所使用的缓冲队列handler: 线程池对拒绝任务的处理策略</code></pre><h5 id="通过Executors创建"><a href="#通过Executors创建" class="headerlink" title="通过Executors创建"></a>通过Executors创建</h5><ul><li><p>newCachedThreadPool<br>是一个可根据需要创建新线程的线程池，以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。调用 execute() 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资源。注意，可以使用 ThreadPoolExecutor 构造方法创建具有类似属性但细节不同（例如超时参数）的线程池。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>newSingleThreadExecutor 创建是一个单线程池，也就是该线程池只有一个线程在工作，所有的任务是串行执行的，如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">           (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                   <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                   <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>newFixedThreadPool 创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大值小，线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>newScheduledThreadPool 创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">           <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="BlockingQueue介绍"><a href="#BlockingQueue介绍" class="headerlink" title="BlockingQueue介绍"></a>BlockingQueue介绍</h4><p>queue上的三种类型。</p><h5 id="排队有三种通用策略："><a href="#排队有三种通用策略：" class="headerlink" title="排队有三种通用策略："></a>排队有三种通用策略：</h5><p>直接提交。工作队列的默认选项是 SynchronousQueue，它将任务直接提交给线程而不保持它们。在此，如果不存在可用于立即运行任务的线程，则试图把任务加入队列将失败，因此会构造一个新的线程。此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。直接提交通常要求无界 maximumPoolSizes以避免拒绝新提交的任务。当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。</p><p>无界队列。使用无界队列（例如，不具有预定义容量的 LinkedBlockingQueue）将导致在所有 corePoolSize 线程都忙时新任务在队列中等待。这样，创建的线程就不会超过 corePoolSize。（因此，maximumPoolSize的值也就无效了。）当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；例如，在 Web页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。</p><p>有界队列。当使用有限的 maximumPoolSizes时，有界队列（如 ArrayBlockingQueue）有助于防止资源耗尽，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O边界），则系统可能为超过您许可的更多线程安排时间。使用小型队列通常要求较大的池大小，CPU使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量。 </p><h5 id="BlockingQueue的选择。"><a href="#BlockingQueue的选择。" class="headerlink" title="BlockingQueue的选择。"></a>BlockingQueue的选择。</h5><ul><li>例子一：使用直接提交策略，也即SynchronousQueue。</li></ul><p>首先SynchronousQueue是无界的，也就是说他存数任务的能力是没有限制的，但是由于该Queue本身的特性，在某次添加元素后必须等待其他线程取走后才能继续添加。在这里不是核心线程便是新创建的线程，但是我们试想一样下，下面的场景。</p><p>我们使用一下参数构造ThreadPoolExecutor：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line"></span><br><span class="line">  <span class="number">2</span>, <span class="number">3</span>, <span class="number">30</span>, TimeUnit.SECONDS,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> RecorderThreadFactory(<span class="string">"CookieRecorderPool"</span>),</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br></pre></td></tr></table></figure><p> 当核心线程已经有2个正在运行.</p><p>此时继续来了一个任务（A），根据前面介绍的“如果运行的线程等于或多于 corePoolSize，则 Executor始终首选将请求加入队列，而不添加新的线程。”,所以A被添加到queue中。<br>又来了一个任务（B），且核心2个线程还没有忙完，OK，接下来首先尝试1中描述，但是由于使用的SynchronousQueue，所以一定无法加入进去。<br>此时便满足了上面提到的“如果无法将请求加入队列，则创建新的线程，除非创建此线程超出maximumPoolSize，在这种情况下，任务将被拒绝。”，所以必然会新建一个线程来运行这个任务。<br>暂时还可以，但是如果这三个任务都还没完成，连续来了两个任务，第一个添加入queue中，后一个呢？queue中无法插入，而线程数达到了maximumPoolSize，所以只好执行异常策略了。<br>所以在使用SynchronousQueue通常要求maximumPoolSize是无界的，这样就可以避免上述情况发生（如果希望限制就直接使用有界队列）。对于使用SynchronousQueue的作用jdk中写的很清楚：此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。</p><p>什么意思？如果你的任务A1，A2有内部关联，A1需要先运行，那么先提交A1，再提交A2，当使用SynchronousQueue我们可以保证，A1必定先被执行，在A1么有被执行前，A2不可能添加入queue中。</p><ul><li>例子二：使用无界队列策略，即LinkedBlockingQueue</li></ul><p>这个就拿newFixedThreadPool来说，根据前文提到的规则：</p><p>如果运行的线程少于 corePoolSize，则 Executor 始终首选添加新的线程，而不进行排队。那么当任务继续增加，会发生什么呢？</p><p>如果运行的线程等于或多于 corePoolSize，则 Executor 始终首选将请求加入队列，而不添加新的线程。OK，此时任务变加入队列之中了，那什么时候才会添加新线程呢？</p><p>如果无法将请求加入队列，则创建新的线程，除非创建此线程超出 maximumPoolSize，在这种情况下，任务将被拒绝。这里就很有意思了，可能会出现无法加入队列吗？不像SynchronousQueue那样有其自身的特点，对于无界队列来说，总是可以加入的（资源耗尽，当然另当别论）。换句说，永远也不会触发产生新的线程！corePoolSize大小的线程数会一直运行，忙完当前的，就从队列中拿任务开始运行。所以要防止任务疯长，比如任务运行的实行比较长，而添加任务的速度远远超过处理任务的时间，而且还不断增加，不一会儿就爆了。</p><ul><li>例子三：有界队列，使用ArrayBlockingQueue。</li></ul><p>这个是最为复杂的使用，所以JDK不推荐使用也有些道理。与上面的相比，最大的特点便是可以防止资源耗尽的情况发生。</p><p>举例来说，请看如下构造方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line"></span><br><span class="line">    <span class="number">2</span>, <span class="number">4</span>, <span class="number">30</span>, TimeUnit.SECONDS,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">2</span>),</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> RecorderThreadFactory(<span class="string">"CookieRecorderPool"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br></pre></td></tr></table></figure><p>假设，所有的任务都永远无法执行完。</p><p>对于首先来的A,B来说直接运行，接下来，如果来了C,D，他们会被放到queue中，如果接下来再来E,F，则增加线程运行E，F。但是如果再来任务，队列无法再接受了，线程数也到达最大的限制了，所以就会使用拒绝策略来处理。</p><h4 id="RejectedExecutionHandler"><a href="#RejectedExecutionHandler" class="headerlink" title="RejectedExecutionHandler"></a>RejectedExecutionHandler</h4><p>ejectedExecutionHandler接口提供了对于拒绝任务的处理的自定方法的机会。在ThreadPoolExecutor中已经默认包含了4中策略，因为源码非常简单，这里直接贴出来。</p><ul><li>CallerRunsPolicy：线程调用运行该任务的 execute 本身。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line"></span><br><span class="line">               r.run();</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li></ul><p>这个策略显然不想放弃执行任务。但是由于池中已经没有任何资源了，那么就直接使用调用该execute的线程本身来执行。</p><ul><li>AbortPolicy：处理程序遭到拒绝将抛出运行时RejectedExecutionException</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException();</span><br><span class="line"></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p> 这种策略直接抛出异常，丢弃任务。</p><ul><li>DiscardPolicy：不能执行的任务将被删除</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p> 这种策略和AbortPolicy几乎一样，也是丢弃任务，只不过他不抛出异常。</p><ul><li>DiscardOldestPolicy：如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序（如果再次失败，则重复此过程）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line"></span><br><span class="line">               e.getQueue().poll();</span><br><span class="line"></span><br><span class="line">               e.execute(r);</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>该策略就稍微复杂一些，在pool没有关闭的前提下首先丢掉缓存在队列中的最早的任务，然后重新尝试运行该任务。这个策略需要适当小心。</p><p>设想:如果其他线程都还在运行，那么新来任务踢掉旧任务，缓存在queue中，再来一个任务又会踢掉queue中最老任务。</p><p>总结：</p><p>keepAliveTime和maximumPoolSize及BlockingQueue的类型均有关系。如果BlockingQueue是无界的，那么永远不会触发maximumPoolSize，自然keepAliveTime也就没有了意义。</p><p>反之，如果核心数较小，有界BlockingQueue数值又较小，同时keepAliveTime又设的很小，如果任务频繁，那么系统就会频繁的申请回收线程。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java中的锁</title>
      <link href="/2019/07/12/java%E4%B8%AD%E7%9A%84%E9%94%81/"/>
      <url>/2019/07/12/java%E4%B8%AD%E7%9A%84%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>参考:<a href="http://www.cnblogs.com/dolphin0520/p/3923167.html" target="_blank" rel="noopener">http://www.cnblogs.com/dolphin0520/p/3923167.html</a></p><h4 id="1-为何出现Lock"><a href="#1-为何出现Lock" class="headerlink" title="1. 为何出现Lock"></a>1. 为何出现Lock</h4><p>采用synchronized关键字来实现同步的话，就会导致一个问题：</p><ul><li>如果多个线程都只是进行读操作，所以当一个线程在进行读操作时，其他线程只能等待无法进行读操作。</li></ul><p>&emsp;&emsp;因此就需要一种机制来使得多个线程都只是进行读操作时，线程之间不会发生冲突，通过Lock就可以办到。<br>   另外，通过Lock可以知道线程有没有成功获取到锁。这个是synchronized无法办到的。</p><p>&emsp;&emsp;总结一下，也就是说Lock提供了比synchronized更多的功能。但是要注意以下几点：</p><p>&emsp;&emsp;1）Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；</p><p>&emsp;&emsp;2）Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。</p><h4 id="2-java-util-concurrent-locks包下常用的接口或类"><a href="#2-java-util-concurrent-locks包下常用的接口或类" class="headerlink" title="2. java.util.concurrent.locks包下常用的接口或类"></a>2. java.util.concurrent.locks包下常用的接口或类</h4><h5 id="2-1-lock"><a href="#2-1-lock" class="headerlink" title="2.1 lock"></a>2.1 lock</h5><p>&emsp;&emsp;Lock是一个接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中lock()、tryLock()、tryLock(long time, TimeUnit unit)和lockInterruptibly()是用来获取锁。</p><p>unLock()方法是用来释放锁。</p><p>newCondition()获得condition,Condition的作用是对锁进行更精确的控制。Condition中的await()方法相当于Object的wait()方法，Condition中的signal()方法相当于Object的notify()方法，Condition中的signalAll()相当于Object的notifyAll()方法。(<a href="https://www.cnblogs.com/dolphin0520/p/3920385.html" target="_blank" rel="noopener">condition具体使用点击</a>)</p><p>&emsp;&emsp;<strong>lock()</strong> 方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。</p><p>注:由于在前面讲到如果采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。通常使用Lock来进行同步的话，是以下面这种形式去使用的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//处理任务</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">     </span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock();   <span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>tryLock()</strong> 方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。</p><p>&emsp;&emsp;<strong>tryLock(long time, TimeUnit unit)</strong> 方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line"><span class="keyword">if</span>(lock.tryLock()) &#123;</span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line">         <span class="comment">//处理任务</span></span><br><span class="line">     &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">         </span><br><span class="line">     &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">         lock.unlock();   <span class="comment">//释放锁</span></span><br><span class="line">     &#125; </span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果不能获取锁，则直接做其他事情</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>lockInterruptibly()</strong> 方法比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就是说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">     <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>，当一个线程获取了锁之后，是不会被interrupt()方法中断的。因为本身在前面的文章中讲过单独调用interrupt()方法不能中断正在运行过程中的线程，只能中断阻塞过程中的线程。</p><p>&emsp;&emsp;因此当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，只有进行等待的情况下，是可以响应中断的。</p><p>&emsp;&emsp;而用synchronized修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。</p><h5 id="2-2-ReentrantLock"><a href="#2-2-ReentrantLock" class="headerlink" title="2.2 ReentrantLock"></a>2.2 ReentrantLock</h5><p>ReentrantLock，意思是“==可重入锁==”，关于可重入锁的概念在下一节讲述。ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法。下面通过一些实例看具体看一下如何使用ReentrantLock。</p><p>eg:Lock.lock</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注意这个地方</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLockDemo test = <span class="keyword">new</span> ReentrantLockDemo();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"得到了锁"</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                arrayList.add(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"释放了锁"</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果:</p><pre><code>Thread-0得到了锁Thread-0释放了锁Thread-1得到了锁Thread-1释放了锁</code></pre><p>eg2:Lock.tryLock</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTryLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注意这个地方</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLockTryLock test = <span class="keyword">new</span> ReentrantLockTryLock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lock.tryLock())&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(thread.getName()+<span class="string">"得到了锁"</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                    arrayList.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(thread.getName()+<span class="string">"释放了锁"</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"获取锁失败!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>eg3:lockInterruptibly()响应中断的使用方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockLockInterruptibly</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        ReentrantLockLockInterruptibly test = <span class="keyword">new</span> ReentrantLockLockInterruptibly();</span><br><span class="line">        MyThread thread1 = <span class="keyword">new</span> MyThread(test);</span><br><span class="line">        MyThread thread2 = <span class="keyword">new</span> MyThread(test);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        thread2.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="comment">//注意，如果需要正确中断等待锁的线程，必须将获取锁放在外面，然后将InterruptedException抛出</span></span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"得到了锁"</span>);</span><br><span class="line">            <span class="keyword">for</span>(    ;     ;) &#123;</span><br><span class="line">                <span class="comment">//插入数据</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"执行finally"</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"释放了锁"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLockLockInterruptibly test = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(ReentrantLockLockInterruptibly test)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.test = test;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test.insert(Thread.currentThread());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"被中断"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果:</p><pre><code>Thread-0得到了锁Thread-1被中断</code></pre><h5 id="2-3-ReadWriteLock"><a href="#2-3-ReadWriteLock" class="headerlink" title="2.3 ReadWriteLock"></a>2.3 ReadWriteLock</h5><p>ReadWriteLock也是一个接口，在它里面只定义了两个方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for reading.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for reading.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for writing.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for writing.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分成2个锁来分配给线程，从而使得多个线程可以同时进行读操作。下面的ReentrantReadWriteLock实现了ReadWriteLock接口。</p><h5 id="2-4-ReentrantReadWriteLock"><a href="#2-4-ReentrantReadWriteLock" class="headerlink" title="2.4 ReentrantReadWriteLock"></a>2.4 ReentrantReadWriteLock</h5><p>ReentrantReadWriteLock里面提供了很多丰富的方法，不过最主要的有两个方法：readLock()和writeLock()用来获取读锁和写锁。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantReadWriteLockDemo test = <span class="keyword">new</span> ReentrantReadWriteLockDemo();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.get(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.get(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">                System.out.println(thread.getName()+<span class="string">"正在进行读操作"</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"读操作完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果:</p><pre><code>Thread-0正在进行读操作Thread-1正在进行读操作Thread-0读操作完毕Thread-1读操作完毕</code></pre><p>ReentrantReadWriteLock允许多个读线程同时访问，但不允许写线程和读线程、写线程和写线程同时访问。相对于排他锁，提高了并发性。在实际应用中，大部分情况下对共享数据（如缓存）的访问都是读操作远多于写操作，这时ReentrantReadWriteLock能够提供比排他锁更好的并发性和吞吐量。</p><h5 id="2-4-Lock和synchronized的选择"><a href="#2-4-Lock和synchronized的选择" class="headerlink" title="2.4 Lock和synchronized的选择"></a>2.4 Lock和synchronized的选择</h5><p>　　总结来说，Lock和synchronized有以下几点不同：</p><p>&emsp;&emsp;1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；</p><p>&emsp;&emsp;2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</p><p>&emsp;&emsp;3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</p><p>&emsp;&emsp;4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</p><p>&emsp;&emsp;5）Lock可以提高多个线程进行读操作的效率。</p><p>&emsp;&emsp;在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</p><h4 id="3-锁的相关概念介绍"><a href="#3-锁的相关概念介绍" class="headerlink" title="3. 锁的相关概念介绍"></a>3. 锁的相关概念介绍</h4><h5 id="3-1-可重入锁"><a href="#3-1-可重入锁" class="headerlink" title="3.1 可重入锁"></a>3.1 可重入锁</h5><p>&emsp;&emsp;如果锁具备可重入性，则称作为可重入锁。像synchronized和ReentrantLock都是可重入锁，可重入性在我看来实际上表明了锁的分配机制：基于线程的分配，而不是基于方法调用的分配。举个简单的例子，当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，此时线程不必重新去申请锁，而是可以直接执行方法method2。</p><p>eg:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述代码中的两个方法method1和method2都用synchronized修饰了，假如某一时刻，线程A执行到了method1，此时线程A获取了这个对象的锁，而由于method2也是synchronized方法，假如synchronized不具备可重入性，此时线程A需要重新申请锁。但是这就会造成一个问题，因为线程A已经持有了该对象的锁，而又在申请获取该对象的锁，这样就会线程A一直等待永远不会获取到的锁。</p><p>&emsp;&emsp;而由于synchronized和Lock都具备可重入性，所以不会发生上述现象。</p><h5 id="3-2-可中断锁"><a href="#3-2-可中断锁" class="headerlink" title="3.2 可中断锁"></a>3.2 可中断锁</h5><p>顾名思义，就是可以相应中断的锁</p><p>在Java中，synchronized就不是可中断锁，而Lock是可中断锁。</p><p>&emsp;&emsp;如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。</p><p>&emsp;&emsp;在前面演示lockInterruptibly()的用法时已经体现了Lock的可中断性。</p><h5 id="3-3公平锁与非公平锁"><a href="#3-3公平锁与非公平锁" class="headerlink" title="3.3公平锁与非公平锁"></a>3.3公平锁与非公平锁</h5><p><strong>公平锁</strong>即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该锁，这种就是公平锁。</p><p><strong>非公平锁</strong>即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。</p><p>&emsp;&emsp;在Java中，==synchronized就是非公平锁==，它无法保证等待的线程获取锁的顺序。而对于ReentrantLock和ReentrantReadWriteLock，它==默认情况下是非公平锁==，但是可以设置为公平锁。</p><p>&emsp;&emsp;在ReentrantLock中定义了2个静态内部类，一个是NotFairSync，一个是FairSync，分别用来实现非公平锁和公平锁。</p><p><img src="/2019/07/12/java中的锁/1562944862015.png" alt="1562944862015"></p><p>&emsp;&emsp;我们可以在创建ReentrantLock对象时，通过以下方式来设置锁的公平性：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果参数为true表示为公平锁，为fasle为非公平锁。默认情况下，如果使用无参构造器，则是非公平锁。</p><p><img src="/2019/07/12/java中的锁/1562944966849.png" alt="1562944966849"><br><img src="/2019/07/12/java中的锁/1562944996384.png" alt="1562944996384"></p><p>另外在ReentrantLock类中定义了很多方法，比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">isFair()        <span class="comment">//判断锁是否是公平锁</span></span><br><span class="line">isLocked()    <span class="comment">//判断锁是否被任何线程获取了</span></span><br><span class="line">isHeldByCurrentThread()   <span class="comment">//判断锁是否被当前线程获取了</span></span><br><span class="line">hasQueuedThreads()   <span class="comment">//判断是否有线程在等待该锁</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在ReentrantReadWriteLock中也有类似的方法，同样也可以设置为公平锁和非公平锁。不过要记住，ReentrantReadWriteLock并未实现Lock接口，它实现的是ReadWriteLock接口。</p><h5 id="3-4-读写锁"><a href="#3-4-读写锁" class="headerlink" title="3.4 读写锁"></a>3.4 读写锁</h5><p>读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁。</p><p>正因为有了读写锁，才使得多个线程之间的读操作不会发生冲突。</p><p>ReadWriteLock就是读写锁，它是一个接口，ReentrantReadWriteLock实现了这个接口。</p><p>可以通过readLock()获取读锁，通过writeLock()获取写锁。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁(Lock) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>幂等性问题</title>
      <link href="/2019/07/12/%E5%B9%82%E7%AD%89%E6%80%A7%E9%97%AE%E9%A2%98/"/>
      <url>/2019/07/12/%E5%B9%82%E7%AD%89%E6%80%A7%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><h5 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h5><p>在传统应用中，调用接口，只有两种状态成功和失败。但是在分布式,微服务的架构下，还有第三种情况，那就是超时！因为超时而进行重试,进行重试调用，就给系统带来了不一致问题了！因此我们必须给调用接口提供幂等性保证，防止重复调用出现不一致的情形！”</p><h5 id="什么是幂等"><a href="#什么是幂等" class="headerlink" title="什么是幂等"></a>什么是幂等</h5><p>幂等性强调的是外界通过接口对系统内部的影响, 外界怎么看系统和幂等性没有关系，只要一次或多次调用对某一个资源应该具有同样的副作用就行。注意了，是对资源造成的副作用必须是一样的，但是返回值允许不同！</p><h5 id="哪些操作会出现幂等性问题"><a href="#哪些操作会出现幂等性问题" class="headerlink" title="哪些操作会出现幂等性问题"></a>哪些操作会出现幂等性问题</h5><ul><li>(1)查询操作<br>查询操作并不会产生或变更新的数据，因此查询是天然具备幂等性。</li><li>(2)删除操作 这里分为物理删除和逻辑删除<ul><li>物理删除:删除只会进行一次，无论执行几次delete操作，造成的效果是一样的！是幂等性操作</li><li>逻辑删除:这类删除，是用update修改字段而已，这种操作无论update几次，造成的效果是一样的！是幂等性操作</li></ul></li><li>(3)增加操作<br>这里要看这张表是否带唯一索引。<ul><li>带唯一索引Insert:此时如果重复插入操作，是会插入失败的！该操作是幂等性操作</li><li>不带唯一索引Insert: <strong>这种情况是非幂等性操作。</strong></li></ul></li><li>(4)修改操作<br>要看修改了啥<ul><li>计算式Update:这类操作是指UPDATE table SET number=number-1 WHERE id=1，这类SQL的操作，<strong>是非幂等性操作！</strong></li><li>非计算式Update:这类操作是指UPDATE table SET number=3 WHERE id=1，这类SQL操作，这种修改是属于幂等性的操作！<h4 id="怎么实现幂等"><a href="#怎么实现幂等" class="headerlink" title="怎么实现幂等"></a>怎么实现幂等</h4>计算式Update和不带唯一索引Insert会出现幂等性问题<h5 id="不带唯一索引Insert"><a href="#不带唯一索引Insert" class="headerlink" title="不带唯一索引Insert:"></a>不带唯一索引Insert:</h5></li></ul></li></ul><p>添加唯一索引</p><p>不想建立索引</p><ul><li>修改插入语句<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">table</span>(field1, field2, fieldn) <span class="keyword">SELECT</span> <span class="string">'field1'</span>, </span><br><span class="line"><span class="string">'field2'</span>, <span class="string">'fieldn'</span> <span class="keyword">FROM</span> DUAL <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(<span class="keyword">SELECT</span> field1,field2,fieldn</span><br><span class="line"> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> field1 = ?)</span><br></pre></td></tr></table></figure></li></ul><p>采用这种写法，就可以防止重复插入，而且不需要建立唯一索引！SQL可以判断field字段有值，则不insert。如果无值，则会执行insert操作！这种方法其实就是使用了mysql的一个临时表的方式，但是里面使用到了子查询，效率也会有一点点影响。但是很重要的一点，这种写法在oracle里也能跑的通，通用性强</p><h5 id="计算式Update"><a href="#计算式Update" class="headerlink" title="计算式Update:"></a>计算式Update:</h5><p>增加版本号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">table</span> <span class="keyword">SET</span> <span class="built_in">number</span>=<span class="built_in">number</span><span class="number">-1</span>，_version=_version+<span class="number">1</span>  </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">AND</span> _version= last_version</span><br></pre></td></tr></table></figure><p>唯一的缺点，就是执行前，需要去数据查一下当前版本是啥！当然啦，如果你的表有唯一索引，用的又是mysql，又能保证将来不换其他数据库。可以试试mysql的on duplicate key update语句，该操作插入时如果发现unique key已存在，则执行update更新操作”</p><p><strong>补充:</strong><br>在数据库层面的改变是最方便的，所以我一直主张，改sql，改表结构来解决幂等性问题。不要引入一堆七七八八的东东，徒增系统复杂度。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 幂等性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何停止一个线程</title>
      <link href="/2019/07/12/%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/07/12/%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h4 id="停止一个线程的方法"><a href="#停止一个线程的方法" class="headerlink" title="停止一个线程的方法"></a>停止一个线程的方法</h4><ol><li>使用interrupt</li><li>使用volatile boolean stop</li></ol><p>代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">/*Thread.sleep这个阻塞方法，接收到中断请求，会抛出InterruptedException，</span></span><br><span class="line"><span class="comment">                    让上层代码处理。会吞掉了中断。因为抛出InterruptedException后，</span></span><br><span class="line"><span class="comment">                    中断标记会被重新设置为false,因此需再次调用interrupt恢复中断，让线程退出。*/</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"thread stop"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">        System.out.println(<span class="string">"i:"</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlagStopDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isStop = <span class="keyword">false</span> ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (!isStop)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"thread stop"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        isStop = <span class="keyword">true</span> ;</span><br><span class="line">        System.out.println(<span class="string">"i:"</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>补充</strong>:<br>要求线程在限定时间内得到结果，否则触发超时中止线程。</p><p>Executor框架提供了Java线程池的能力，ExecutorService扩展了Executor，提供了管理线程生命周期的关键能力。其中，ExecutorService.submit返回了Future对象来描述一个线程任务，它有一个cancel()方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptByFuture</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class="line">        Future&lt;?&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">               i++;</span><br><span class="line">               System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"thread stop"</span>);</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object o = future.get(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            <span class="comment">//超时触发线程中止</span></span><br><span class="line">            System.out.println(<span class="string">"thread over time"</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//中止线程</span></span><br><span class="line">           future.cancel(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//关闭线程池</span></span><br><span class="line">           executor.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cancel()有个参数mayInterruptIfRunning，表示任务是否能够接收到中断。</p><p>mayInterruptIfRunning=true时，任务如果在某个线程中运行，那么这个线程能够被中断；<br>mayInterruptIfRunning=false时，任务如果还未启动，就不要运行它，应用于不处理中断的任务</p><p>要注意，mayInterruptIfRunning=true表示线程能接收中断，但线程是否实现了中断不得而知。线程要正确响应中断，才能真正被cancel。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot</title>
      <link href="/2019/07/12/springboot/"/>
      <url>/2019/07/12/springboot/</url>
      
        <content type="html"><![CDATA[<h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0.学习目标"></a>0.学习目标</h1><ul><li>了解SpringBoot的作用</li><li>掌握java配置的方式</li><li>了解SpringBoot自动配置原理</li><li>掌握SpringBoot的基本使用</li><li>了解Thymeleaf的基本使用</li></ul><h1 id="1-了解SpringBoot"><a href="#1-了解SpringBoot" class="headerlink" title="1. 了解SpringBoot"></a>1. 了解SpringBoot</h1><p>在这一部分，我们主要了解以下3个问题：</p><ul><li>什么是SpringBoot</li><li>为什么要学习SpringBoot</li><li>SpringBoot的特点</li></ul><h2 id="1-1-什么是SpringBoot"><a href="#1-1-什么是SpringBoot" class="headerlink" title="1.1.什么是SpringBoot"></a>1.1.什么是SpringBoot</h2><p>SpringBoot是Spring项目中的一个子工程，与我们所熟知的Spring-framework 同属于spring的产品:</p><p><img src="/2019/07/12/springboot/1525484756737.png" alt></p><p>我们可以看到下面的一段介绍：</p><blockquote><p>Takes an opinionated view of building production-ready Spring applications. Spring Boot favors convention over configuration and is designed to get you up and running as quickly as possible.</p></blockquote><p>翻译一下：</p><blockquote><p>用一些固定的方式来构建生产级别的spring应用。Spring Boot 推崇约定大于配置的方式以便于你能够尽可能快速的启动并运行程序。</p></blockquote><p>其实人们把Spring Boot 称为搭建程序的<code>脚手架</code>。其最主要作用就是帮我们快速的构建庞大的spring项目，并且尽可能的减少一切xml配置，做到开箱即用，迅速上手，让我们关注与业务而非配置。</p><h2 id="1-2-为什么要学习SpringBoot"><a href="#1-2-为什么要学习SpringBoot" class="headerlink" title="1.2.为什么要学习SpringBoot"></a>1.2.为什么要学习SpringBoot</h2><p>java一直被人诟病的一点就是臃肿、麻烦。当我们还在辛苦的搭建项目时，可能Python程序员已经把功能写好了，究其原因注意是两点：</p><ul><li><p>复杂的配置，</p><p>项目各种配置其实是开发时的损耗， 因为在思考 Spring 特性配置和解决业务问题之间需要进行思维切换，所以写配置挤占了写应用程序逻辑的时间。</p></li><li><p>一个是混乱的依赖管理。</p><p>项目的依赖管理也是件吃力不讨好的事情。决定项目里要用哪些库就已经够让人头痛的了，你还要知道这些库的哪个版本和其他库不会有冲突，这难题实在太棘手。并且，依赖管理也是一种损耗，添加依赖不是写应用程序代码。一旦选错了依赖的版本，随之而来的不兼容问题毫无疑问会是生产力杀手。</p></li></ul><p>而SpringBoot让这一切成为过去！</p><blockquote><p>Spring Boot 简化了基于Spring的应用开发，只需要“run”就能创建一个独立的、生产级别的Spring应用。Spring Boot为Spring平台及第三方库提供开箱即用的设置（提供默认设置，存放默认配置的包就是启动器），这样我们就可以简单的开始。多数Spring Boot应用只需要很少的Spring配置。</p></blockquote><p>我们可以使用SpringBoot创建java应用，并使用java –jar 启动它，就能得到一个生产级别的web工程。</p><h2 id="1-3-SpringBoot的特点"><a href="#1-3-SpringBoot的特点" class="headerlink" title="1.3.SpringBoot的特点"></a>1.3.SpringBoot的特点</h2><p>Spring Boot 主要目标是：</p><ul><li>为所有 Spring 的开发者提供一个非常快速的、广泛接受的入门体验</li><li>开箱即用（启动器starter-其实就是SpringBoot提供的一个jar包），但通过自己设置参数（.properties），即可快速摆脱这种方式。</li><li>提供了一些大型项目中常见的非功能性特性，如内嵌服务器、安全、指标，健康检测、外部化配置等</li><li>绝对没有代码生成，也无需 XML 配置。</li></ul><p>更多细节，大家可以到<a href="http://projects.spring.io/spring-boot/" target="_blank" rel="noopener">官网</a>查看。</p><h1 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2.快速入门"></a>2.快速入门</h1><p>接下来，我们就来利用SpringBoot搭建一个web工程，体会一下SpringBoot的魅力所在！</p><h2 id="2-1-创建工程"><a href="#2-1-创建工程" class="headerlink" title="2.1.创建工程"></a>2.1.创建工程</h2><p>我们先新建一个空的工程：</p><p><img src="/2019/07/12/springboot/1525485888078.png" alt="1525485888078"></p><p>工程名为demo</p><p>新建一个model：</p><p> <img src="/2019/07/12/springboot/1525486079389.png" alt="1525486079389"></p><p>使用maven来构建：</p><p><img src="/2019/07/12/springboot/1525486188374.png" alt="1525486188374"></p><p>然后填写项目坐标：</p><p> <img src="/2019/07/12/springboot/1525486236967.png" alt="1525486236967"></p><p>目录结构：</p><p> <img src="/2019/07/12/springboot/1525486282929.png" alt="1525486282929"></p><p>项目结构：</p><p> <img src="/2019/07/12/springboot/1525486435199.png" alt="1525486435199"></p><h2 id="2-2-添加依赖"><a href="#2-2-添加依赖" class="headerlink" title="2.2.添加依赖"></a>2.2.添加依赖</h2><p>看到这里很多同学会有疑惑，前面说传统开发的问题之一就是依赖管理混乱，怎么这里我们还需要管理依赖呢？难道SpringBoot不帮我们管理吗？</p><p>别着急，现在我们的项目与SpringBoot还没有什么关联。SpringBoot提供了一个名为spring-boot-starter-parent的工程，里面已经对各种常用依赖（并非全部）的版本进行了管理，我们的项目需要以这个项目为父工程，这样我们就不用操心依赖的版本问题了，需要什么依赖，直接引入坐标即可！</p><h3 id="2-2-1-添加父工程坐标"><a href="#2-2-1-添加父工程坐标" class="headerlink" title="2.2.1.添加父工程坐标"></a>2.2.1.添加父工程坐标</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-2-添加web启动器"><a href="#2-2-2-添加web启动器" class="headerlink" title="2.2.2.添加web启动器"></a>2.2.2.添加web启动器</h3><p>为了让SpringBoot帮我们完成各种自动配置，我们必须引入SpringBoot提供的自动配置依赖，我们称为<code>启动器</code>。因为我们是web项目，这里我们引入web启动器：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是，我们并没有在这里指定版本信息。因为SpringBoot的父工程已经对版本进行了管理了。</p><p>这个时候，我们会发现项目中多出了大量的依赖：</p><p> <img src="/2019/07/12/springboot/1525486980765.png" alt="1525486980765"></p><p>这些都是SpringBoot根据spring-boot-starter-web这个依赖自动引入的，而且所有的版本都已经管理好，不会出现冲突。</p><h3 id="2-2-3-管理jdk版本"><a href="#2-2-3-管理jdk版本" class="headerlink" title="2.2.3.管理jdk版本"></a>2.2.3.管理jdk版本</h3><p>默认情况下，maven工程的jdk版本是1.5，而我们开发使用的是1.8，因此这里我们需要修改jdk版本，只需要简单的添加以下属性即可：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-4-完整pom"><a href="#2-2-4-完整pom" class="headerlink" title="2.2.4.完整pom"></a>2.2.4.完整pom</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.leyou.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-3-启动类"><a href="#2-3-启动类" class="headerlink" title="2.3.启动类"></a>2.3.启动类</h2><p>Spring Boot项目通过main函数即可启动，我们需要创建一个启动类：</p><p> <img src="/2019/07/12/springboot/1525487293907.png" alt="1525487293907"></p><p>然后编写main函数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-编写controller"><a href="#2-4-编写controller" class="headerlink" title="2.4.编写controller"></a>2.4.编写controller</h2><p>接下来，我们就可以像以前那样开发SpringMVC的项目了！</p><p>我们编写一个controller：</p><p> <img src="/2019/07/12/springboot/1525487465325.png" alt="1525487465325"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello, spring boot!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-启动测试"><a href="#2-5-启动测试" class="headerlink" title="2.5.启动测试"></a>2.5.启动测试</h2><p>接下来，我们运行main函数，查看控制台：</p><p> <img src="/2019/07/12/springboot/1525487613365.png" alt="1525487613365"></p><p>并且可以看到监听的端口信息：</p><p> <img src="/2019/07/12/springboot/1525487705460.png" alt="1525487705460"></p><ul><li>1）监听的端口是8080</li><li>2）SpringMVC的映射路径是：/</li><li>3）<code>/hello</code>路径已经映射到了<code>HelloController</code>中的<code>hello()</code>方法</li></ul><p>打开页面访问：<a href="http://localhost:8080/hello" target="_blank" rel="noopener">http://localhost:8080/hello</a></p><p> <img src="/2019/07/12/springboot/1525487820824.png" alt="1525487820824"></p><p>测试成功了！</p><h1 id="3-Java配置"><a href="#3-Java配置" class="headerlink" title="3.Java配置"></a>3.Java配置</h1><p>在入门案例中，我们没有任何的配置，就可以实现一个SpringMVC的项目了，快速、高效！</p><p>但是有同学会有疑问，如果没有任何的xml，那么我们如果要配置一个Bean该怎么办？比如我们要配置一个数据库连接池，以前会这么玩：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">init-method</span>=<span class="string">"init"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在该怎么做呢？</p><h2 id="3-1-回顾历史"><a href="#3-1-回顾历史" class="headerlink" title="3.1.回顾历史"></a>3.1.回顾历史</h2><p>事实上，在Spring3.0开始，Spring官方就已经开始推荐使用java配置来代替传统的xml配置了，我们不妨来回顾一下Spring的历史：</p><ul><li><p>Spring1.0时代</p><p>在此时因为jdk1.5刚刚出来，注解开发并未盛行，因此一切Spring配置都是xml格式，想象一下所有的bean都用xml配置，细思极恐啊，心疼那个时候的程序员2秒</p></li><li><p>Spring2.0时代</p><p>Spring引入了注解开发，但是因为并不完善，因此并未完全替代xml，此时的程序员往往是把xml与注解进行结合，貌似我们之前都是这种方式。</p></li><li><p>Spring3.0及以后</p><p>3.0以后Spring的注解已经非常完善了，因此Spring推荐大家使用完全的java配置来代替以前的xml，不过似乎在国内并未推广盛行。然后当SpringBoot来临，人们才慢慢认识到java配置的优雅。</p></li></ul><p>有句古话说的好：拥抱变化，拥抱未来。所以我们也应该顺应时代潮流，做时尚的弄潮儿，一起来学习下java配置的玩法。</p><h2 id="3-2-尝试java配置"><a href="#3-2-尝试java配置" class="headerlink" title="3.2.尝试java配置"></a>3.2.尝试java配置</h2><p>java配置主要靠java类和一些注解，比较常用的注解有：</p><ul><li><code>@Configuration</code>：声明一个类作为配置类，代替xml文件</li><li><code>@Bean</code>：声明在方法上，将方法的返回值加入Bean容器，代替<code>&lt;bean&gt;</code>标签</li><li><code>@value</code>：属性注入</li><li><code>@PropertySource</code>：指定外部属性文件，</li></ul><p>我们接下来用java配置来尝试实现连接池配置：</p><p>首先引入Druid连接池依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建一个jdbc.properties文件，编写jdbc属性：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jdbc.driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://127.0.0.1:3306/leyou</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=123</span><br></pre></td></tr></table></figure><p>然后编写代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:jdbc.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.url&#125;"</span>)</span><br><span class="line">    String url;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.driverClassName&#125;"</span>)</span><br><span class="line">    String driverClassName;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.username&#125;"</span>)</span><br><span class="line">    String username;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.password&#125;"</span>)</span><br><span class="line">    String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setDriverClassName(driverClassName);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解读：</p><ul><li><code>@Configuration</code>：声明我们<code>JdbcConfig</code>是一个配置类</li><li><code>@PropertySource</code>：指定属性文件的路径是:<code>classpath:jdbc.properties</code></li><li>通过<code>@Value</code>为属性注入值</li><li>通过@Bean将 <code>dataSource()</code>方法声明为一个注册Bean的方法，Spring会自动调用该方法，将方法的返回值加入Spring容器中。</li></ul><p>然后我们就可以在任意位置通过<code>@Autowired</code>注入DataSource了！</p><p>我们在<code>HelloController</code>中测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello, spring boot!"</span> + dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后Debug运行并查看：</p><p><img src="/2019/07/12/springboot/1525492528558.png" alt="1525492528558"></p><p>属性注入成功了！</p><h2 id="3-3-SpringBoot的属性注入"><a href="#3-3-SpringBoot的属性注入" class="headerlink" title="3.3.SpringBoot的属性注入"></a>3.3.SpringBoot的属性注入</h2><p>在上面的案例中，我们实验了java配置方式。不过属性注入使用的是@Value注解。这种方式虽然可行，但是不够强大，因为它只能注入基本类型值。</p><p>在SpringBoot中，提供了一种新的属性注入方式，支持各种java基本数据类型及复杂类型的注入。</p><p>1）我们新建一个类，用来进行属性注入：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"jdbc"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String driverClassName;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">    <span class="comment">// getters 和 setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在类上通过@ConfigurationProperties注解声明当前类为属性读取类</p></li><li><p><code>prefix=&quot;jdbc&quot;</code>读取属性文件中，前缀为jdbc的值。</p></li><li><p>在类上定义各个属性，名称必须与属性文件中<code>jdbc.</code>后面部分一致</p></li><li><p>需要注意的是，这里我们并没有指定属性文件的地址，所以我们需要把jdbc.properties名称改为application.properties，这是SpringBoot默认读取的属性文件名：</p><p> <img src="/2019/07/12/springboot/1525496325572.png" alt="1525496325572"></p></li></ul><p>2）在JdbcConfig中使用这个属性：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(JdbcProperties.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">(JdbcProperties jdbc)</span> </span>&#123;</span><br><span class="line">        DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        dataSource.setUrl(jdbc.getUrl());</span><br><span class="line">        dataSource.setDriverClassName(jdbc.getDriverClassName());</span><br><span class="line">        dataSource.setUsername(jdbc.getUsername());</span><br><span class="line">        dataSource.setPassword(jdbc.getPassword());</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>通过<code>@EnableConfigurationProperties(JdbcProperties.class)</code>来声明要使用<code>JdbcProperties</code>这个类的对象</p></li><li><p>然后你可以通过以下方式注入JdbcProperties：</p><ul><li><p>@Autowired注入</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JdbcProperties prop;</span><br></pre></td></tr></table></figure></li><li><p>构造函数注入</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> JdbcProperties prop;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JdbcConfig</span><span class="params">(Jdbcproperties prop)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.prop = prop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>声明有@Bean的方法参数注入</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Datasource <span class="title">dataSource</span><span class="params">(JdbcProperties prop)</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>本例中，我们采用第三种方式。</p><p>3）测试结果：</p><p><img src="/2019/07/12/springboot/1525492528558.png" alt="1525492528558"></p><p>大家会觉得这种方式似乎更麻烦了，事实上这种方式有更强大的功能，也是SpringBoot推荐的注入方式。两者对比关系：</p><p><img src="/2019/07/12/springboot/1525496543249.png" alt="1525496543249"></p><p>优势：</p><ul><li><p>Relaxed binding：松散绑定</p><ul><li><p>不严格要求属性文件中的属性名与成员变量名一致。支持驼峰，中划线，下划线等等转换，甚至支持对象引导。比如：user.friend.name：代表的是user对象中的friend属性中的name属性，显然friend也是对象。@value注解就难以完成这样的注入方式。</p></li><li><p>meta-data support：元数据支持，帮助IDE生成属性提示（写开源框架会用到）。</p></li></ul></li></ul><h2 id="3-4、更优雅的注入"><a href="#3-4、更优雅的注入" class="headerlink" title="3.4、更优雅的注入"></a>3.4、更优雅的注入</h2><p>事实上，如果一段属性只有一个Bean需要使用，我们无需将其注入到一个类（JdbcProperties）中。而是直接在需要的地方声明即可：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">// 声明要注入的属性前缀，SpringBoot会自动把相关属性通过set方法注入到DataSource中</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"jdbc"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们直接把<code>@ConfigurationProperties(prefix = &quot;jdbc&quot;)</code>声明在需要使用的<code>@Bean</code>的方法上，然后SpringBoot就会自动调用这个Bean（此处是DataSource）的set方法，然后完成注入。使用的前提是：<strong>该类必须有对应属性的set方法！</strong></p><p>我们将jdbc的url改成：/heima，再次测试：</p><p><img src="/2019/07/12/springboot/1525497513206.png" alt="1525497513206"></p><h1 id="4-自动配置原理"><a href="#4-自动配置原理" class="headerlink" title="4.自动配置原理"></a>4.自动配置原理</h1><p>使用SpringBoot之后，一个整合了SpringMVC的WEB工程开发，变的无比简单，那些繁杂的配置都消失不见了，这是如何做到的？</p><p>一切魔力的开始，都是从我们的main函数来的，所以我们再次来看下启动类：</p><p> <img src="/2019/07/12/springboot/1525488044650.png" alt="1525488044650"></p><p>我们发现特别的地方有两个：</p><ul><li>注解：@SpringBootApplication</li><li>run方法：SpringApplication.run()</li></ul><p>我们分别来研究这两个部分。</p><h2 id="4-1-了解-SpringBootApplication"><a href="#4-1-了解-SpringBootApplication" class="headerlink" title="4.1.了解@SpringBootApplication"></a>4.1.了解@SpringBootApplication</h2><p>点击进入，查看源码：</p><p><img src="/2019/07/12/springboot/1525488226710.png" alt="1525488226710"></p><p>这里重点的注解有3个：</p><ul><li>@SpringBootConfiguration</li><li>@EnableAutoConfiguration</li><li>@ComponentScan</li></ul><h3 id="4-1-1-SpringBootConfiguration"><a href="#4-1-1-SpringBootConfiguration" class="headerlink" title="4.1.1.@SpringBootConfiguration"></a>4.1.1.@SpringBootConfiguration</h3><p>我们继续点击查看源码：</p><p><img src="/2019/07/12/springboot/1525488518514.png" alt="1525488518514"></p><p>通过这段我们可以看出，在这个注解上面，又有一个<code>@Configuration</code>注解。通过上面的注释阅读我们知道：这个注解的作用就是声明当前类是一个配置类，然后Spring会自动扫描到添加了<code>@Configuration</code>的类，并且读取其中的配置信息。而<code>@SpringBootConfiguration</code>是来声明当前类是SpringBoot应用的配置类，项目中只能有一个。所以一般我们无需自己添加。</p><h3 id="4-1-2-EnableAutoConfiguration"><a href="#4-1-2-EnableAutoConfiguration" class="headerlink" title="4.1.2.@EnableAutoConfiguration"></a>4.1.2.@EnableAutoConfiguration</h3><p>关于这个注解，官网上有一段说明：</p><blockquote><p>The second class-level annotation is <code>@EnableAutoConfiguration</code>. This annotation<br>tells Spring Boot to “guess” how you want to configure Spring, based on the jar<br>dependencies that you have added. Since <code>spring-boot-starter-web</code> added Tomcat<br>and Spring MVC, the auto-configuration assumes that you are developing a web<br>application and sets up Spring accordingly.</p></blockquote><p>简单翻译以下：</p><blockquote><p>第二级的注解<code>@EnableAutoConfiguration</code>，告诉SpringBoot基于你所添加的依赖，去“猜测”你想要如何配置Spring。比如我们引入了<code>spring-boot-starter-web</code>，而这个启动器中帮我们添加了<code>tomcat</code>、<code>SpringMVC</code>的依赖。此时自动配置就知道你是要开发一个web应用，所以就帮你完成了web及SpringMVC的默认配置了！</p></blockquote><p>总结，SpringBoot内部对大量的第三方库或Spring内部库进行了默认配置，这些配置是否生效，取决于我们是否引入了对应库所需的依赖，如果有那么默认配置就会生效。</p><p>所以，我们使用SpringBoot构建一个项目，只需要引入所需框架的依赖，配置就可以交给SpringBoot处理了。除非你不希望使用SpringBoot的默认配置，它也提供了自定义配置的入口。</p><h4 id="4-1-3-ComponentScan"><a href="#4-1-3-ComponentScan" class="headerlink" title="4.1.3.@ComponentScan"></a>4.1.3.@ComponentScan</h4><p>我们跟进源码：</p><p> <img src="/2019/07/12/springboot/1525498265579.png" alt="1525498265579"></p><p>并没有看到什么特殊的地方。我们查看注释：</p><p> <img src="/2019/07/12/springboot/1525498351385.png" alt="1525498351385"></p><p>大概的意思：</p><blockquote><p>配置组件扫描的指令。提供了类似与<code>&lt;context:component-scan&gt;</code>标签的作用</p><p>通过basePackageClasses或者basePackages属性来指定要扫描的包。如果没有指定这些属性，那么将从声明这个注解的类所在的包开始，扫描包及子包</p></blockquote><p>而我们的@SpringBootApplication注解声明的类就是main函数所在的启动类，因此扫描的包是该类所在包及其子包。因此，<strong>一般启动类会放在一个比较前的包目录中。</strong></p><h2 id="4-2-默认配置原理"><a href="#4-2-默认配置原理" class="headerlink" title="4.2.默认配置原理"></a>4.2.默认配置原理</h2><h3 id="4-2-1默认配置类"><a href="#4-2-1默认配置类" class="headerlink" title="4.2.1默认配置类"></a>4.2.1默认配置类</h3><p>通过刚才的学习，我们知道@EnableAutoConfiguration会开启SpringBoot的自动配置，并且根据你引入的依赖来生效对应的默认配置。那么问题来了：</p><ul><li>这些默认配置是在哪里定义的呢？</li><li>为何依赖引入就会触发配置呢？</li></ul><p>其实在我们的项目中，已经引入了一个依赖：spring-boot-autoconfigure，其中定义了大量自动配置类：</p><p> <img src="/2019/07/12/springboot/1525499397690.png" alt="1525499397690"></p><p>还有：</p><p> <img src="/2019/07/12/springboot/1525499426598.png" alt="1525499426598"></p><p>非常多，几乎涵盖了现在主流的开源框架，例如：</p><ul><li>redis</li><li>jms</li><li>amqp</li><li>jdbc</li><li>jackson</li><li>mongodb</li><li>jpa</li><li>solr</li><li>elasticsearch</li></ul><p>… 等等</p><p>我们来看一个我们熟悉的，例如SpringMVC，查看mvc 的自动配置类：</p><p> <img src="/2019/07/12/springboot/1525499859426.png" alt="1525499859426"></p><p>打开WebMvcAutoConfiguration：</p><p><img src="/2019/07/12/springboot/1525500000816.png" alt="1525500000816"></p><p>我们看到这个类上的4个注解：</p><ul><li><code>@Configuration</code>：声明这个类是一个配置类</li></ul><ul><li><p><code>@ConditionalOnWebApplication(type = Type.SERVLET)</code></p><p>ConditionalOn，翻译就是在某个条件下，此处就是满足项目的类是是Type.SERVLET类型，也就是一个普通web工程，显然我们就是</p></li><li><p><code>@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class })</code></p><p>这里的条件是OnClass，也就是满足以下类存在：Servlet、DispatcherServlet、WebMvcConfigurer，其中Servlet只要引入了tomcat依赖自然会有，后两个需要引入SpringMVC才会有。这里就是判断你是否引入了相关依赖，引入依赖后该条件成立，当前类的配置才会生效！</p></li><li><p><code>@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</code></p><p>这个条件与上面不同，OnMissingBean，是说环境中没有指定的Bean这个才生效。其实这就是自定义配置的入口，也就是说，如果我们自己配置了一个WebMVCConfigurationSupport的类，那么这个默认配置就会失效！</p></li></ul><p>接着，我们查看该类中定义了什么：</p><p>视图解析器：</p><p> <img src="/2019/07/12/springboot/1525500405278.png" alt="1525500405278"></p><p>处理器适配器（HandlerAdapter）：</p><p> <img src="/2019/07/12/springboot/1525500452517.png" alt="1525500452517"></p><p>还有很多，这里就不一一截图了。</p><h3 id="4-2-2-默认配置属性"><a href="#4-2-2-默认配置属性" class="headerlink" title="4.2.2.默认配置属性"></a>4.2.2.默认配置属性</h3><p>另外，这些默认配置的属性来自哪里呢？</p><p><img src="/2019/07/12/springboot/1525500697391.png" alt="1525500697391"></p><p>我们看到，这里通过@EnableAutoConfiguration注解引入了两个属性：WebMvcProperties和ResourceProperties。这不正是SpringBoot的属性注入玩法嘛。</p><p>我们查看这两个属性类：</p><p> <img src="/2019/07/12/springboot/1525500810914.png" alt="1525500810914"></p><p>找到了内部资源视图解析器的prefix和suffix属性。</p><p>ResourceProperties中主要定义了静态资源（.js,.html,.css等)的路径：</p><p> <img src="/2019/07/12/springboot/1525500921773.png" alt="1525500921773"></p><p>如果我们要覆盖这些默认属性，只需要在application.properties中定义与其前缀prefix和字段名一致的属性即可。</p><h2 id="4-3-总结"><a href="#4-3-总结" class="headerlink" title="4.3.总结"></a>4.3.总结</h2><p>SpringBoot为我们提供了默认配置，而默认配置生效的条件一般有两个：</p><ul><li>你引入了相关依赖</li><li>你自己没有配置</li></ul><p>1）启动器</p><p>所以，我们如果不想配置，只需要引入依赖即可，而依赖版本我们也不用操心，因为只要引入了SpringBoot提供的stater（启动器），就会自动管理依赖及版本了。</p><p>因此，玩SpringBoot的第一件事情，就是找启动器，SpringBoot提供了大量的默认启动器，参考课前资料中提供的《SpringBoot启动器.txt》</p><p>2）全局配置</p><p>另外，SpringBoot的默认配置，都会读取默认属性，而这些属性可以通过自定义<code>application.properties</code>文件来进行覆盖。这样虽然使用的还是默认配置，但是配置中的值改成了我们自定义的。</p><p>因此，玩SpringBoot的第二件事情，就是通过<code>application.properties</code>来覆盖默认属性值，形成自定义配置。我们需要知道SpringBoot的默认属性key，非常多，参考课前资料提供的：《SpringBoot全局属性.md》</p><h1 id="5-SpringBoot实践"><a href="#5-SpringBoot实践" class="headerlink" title="5.SpringBoot实践"></a>5.SpringBoot实践</h1><p>接下来，我们来看看如何用SpringBoot来玩转以前的SSM,我们沿用之前讲解SSM用到的数据库tb_user和实体类User</p><h2 id="5-1-整合SpringMVC"><a href="#5-1-整合SpringMVC" class="headerlink" title="5.1.整合SpringMVC"></a>5.1.整合SpringMVC</h2><p>虽然默认配置已经可以使用SpringMVC了，不过我们有时候需要进行自定义配置。</p><h3 id="5-1-1-修改端口"><a href="#5-1-1-修改端口" class="headerlink" title="5.1.1.修改端口"></a>5.1.1.修改端口</h3><p>查看SpringBoot的全局属性可知，端口通过以下方式配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 映射端口</span><br><span class="line">server.port=80</span><br></pre></td></tr></table></figure><p>重启服务后测试：</p><p> <img src="/2019/07/12/springboot/1525511878440.png" alt="1525511878440"></p><h3 id="5-1-2-访问静态资源"><a href="#5-1-2-访问静态资源" class="headerlink" title="5.1.2.访问静态资源"></a>5.1.2.访问静态资源</h3><p>现在，我们的项目是一个jar工程，那么就没有webapp，我们的静态资源该放哪里呢？</p><p>回顾我们上面看的源码，有一个叫做ResourceProperties的类，里面就定义了静态资源的默认查找路径：</p><p> <img src="/2019/07/12/springboot/1525500921773.png" alt="1525500921773"></p><p>默认的静态资源路径为：</p><ul><li>classpath:/META-INF/resources/</li><li>classpath:/resources/</li><li>classpath:/static/</li><li>classpath:/public</li></ul><p>只要静态资源放在这些目录中任何一个，SpringMVC都会帮我们处理。</p><p>我们习惯会把静态资源放在<code>classpath:/static/</code>目录下。我们创建目录，并且添加一些静态资源：</p><p> <img src="/2019/07/12/springboot/1525512196866.png" alt="1525512196866"></p><p>重启项目后测试：</p><p> <img src="/2019/07/12/springboot/1525512253682.png" alt="1525512253682"></p><h3 id="5-1-3-添加拦截器"><a href="#5-1-3-添加拦截器" class="headerlink" title="5.1.3.添加拦截器"></a>5.1.3.添加拦截器</h3><p>拦截器也是我们经常需要使用的，在SpringBoot中该如何配置呢？</p><p>拦截器不是一个普通属性，而是一个类，所以就要用到java配置方式了。在SpringBoot官方文档中有这么一段说明：</p><blockquote><p>If you want to keep Spring Boot MVC features and you want to add additional <a href="https://docs.spring.io/spring/docs/5.0.5.RELEASE/spring-framework-reference/web.html#mvc" target="_blank" rel="noopener">MVC configuration</a> (interceptors, formatters, view controllers, and other features), you can add your own <code>@Configuration</code> class of type <code>WebMvcConfigurer</code> but <strong>without</strong> <code>@EnableWebMvc</code>. If you wish to provide custom instances of <code>RequestMappingHandlerMapping</code>, <code>RequestMappingHandlerAdapter</code>, or <code>ExceptionHandlerExceptionResolver</code>, you can declare a <code>WebMvcRegistrationsAdapter</code> instance to provide such components.</p><p>If you want to take complete control of Spring MVC, you can add your own <code>@Configuration</code> annotated with <code>@EnableWebMvc</code>.</p></blockquote><p>翻译：</p><blockquote><p>如果你想要保持Spring Boot 的一些默认MVC特征，同时又想自定义一些MVC配置（包括：拦截器，格式化器, 视图控制器、消息转换器 等等），你应该让一个类实现<code>WebMvcConfigurer</code>，并且添加<code>@Configuration</code>注解，但是<strong>千万不要</strong>加<code>@EnableWebMvc</code>注解。如果你想要自定义<code>HandlerMapping</code>、<code>HandlerAdapter</code>、<code>ExceptionResolver</code>等组件，你可以创建一个<code>WebMvcRegistrationsAdapter</code>实例 来提供以上组件。</p><p>如果你想要完全自定义SpringMVC，不保留SpringBoot提供的一切特征，你可以自己定义类并且添加<code>@Configuration</code>注解和<code>@EnableWebMvc</code>注解</p></blockquote><p>总结：通过实现<code>WebMvcConfigurer</code>并添加<code>@Configuration</code>注解来实现自定义部分SpringMvc配置。</p><p>首先我们定义一个拦截器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(LoginInterceptor.class);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> </span>&#123;</span><br><span class="line">        logger.debug(<span class="string">"preHandle method is now running!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> </span>&#123;</span><br><span class="line">        logger.debug(<span class="string">"postHandle method is now running!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> </span>&#123;</span><br><span class="line">        logger.debug(<span class="string">"afterCompletion method is now running!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们定义配置类，注册拦截器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过<span class="doctag">@Bean</span>注解，将我们定义的拦截器注册到Spring容器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LoginInterceptor <span class="title">loginInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LoginInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写接口中的addInterceptors方法，添加自定义拦截器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过registry来注册拦截器，通过addPathPatterns来添加拦截路径</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">this</span>.loginInterceptor()).addPathPatterns(<span class="string">"/**"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构如下：</p><p> <img src="/2019/07/12/springboot/1525513555179.png" alt="1525513555179"></p><p>接下来运行并查看日志：</p><p>你会发现日志中什么都没有，因为我们记录的log级别是debug，默认是显示info以上，我们需要进行配置。</p><p>SpringBoot通过<code>logging.level.*=debug</code>来配置日志级别，*填写包名</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置com.leyou包的日志级别为debug</span><br><span class="line">logging.level.com.leyou=debug</span><br></pre></td></tr></table></figure><p>再次运行查看：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">2018</span>-<span class="number">05</span>-<span class="number">05</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">01</span><span class="variable">.811</span> DEBUG <span class="number">4548</span> --- [p-nio-<span class="number">80</span>-exec-<span class="number">1</span>] com<span class="variable">.leyou</span><span class="variable">.interceptor</span><span class="variable">.LoginInterceptor</span>   : preHandle method is now running!</span><br><span class="line"><span class="number">2018</span>-<span class="number">05</span>-<span class="number">05</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">01</span><span class="variable">.854</span> DEBUG <span class="number">4548</span> --- [p-nio-<span class="number">80</span>-exec-<span class="number">1</span>] com<span class="variable">.leyou</span><span class="variable">.interceptor</span><span class="variable">.LoginInterceptor</span>   : postHandle method is now running!</span><br><span class="line"><span class="number">2018</span>-<span class="number">05</span>-<span class="number">05</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">01</span><span class="variable">.854</span> DEBUG <span class="number">4548</span> --- [p-nio-<span class="number">80</span>-exec-<span class="number">1</span>] com<span class="variable">.leyou</span><span class="variable">.interceptor</span><span class="variable">.LoginInterceptor</span>   : afterCompletion method is now running!</span><br></pre></td></tr></table></figure><h2 id="5-2-整合jdbc和事务"><a href="#5-2-整合jdbc和事务" class="headerlink" title="5.2.整合jdbc和事务"></a>5.2.整合jdbc和事务</h2><p>spring中的jdbc连接和事务是配置中的重要一环，在SpringBoot中该如何处理呢？</p><p>答案是不需要处理，我们只要找到SpringBoot提供的启动器即可：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然，不要忘了数据库驱动，SpringBoot并不知道我们用的什么数据库，这里我们选择MySQL：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>至于事务，SpringBoot中通过注解来控制。就是我们熟知的<code>@Transactional</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryById</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userMapper.selectByPrimaryKey(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userMapper.deleteByPrimaryKey(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-3-整合连接池"><a href="#5-3-整合连接池" class="headerlink" title="5.3.整合连接池"></a>5.3.整合连接池</h2><p>其实，在刚才引入jdbc启动器的时候，SpringBoot已经自动帮我们引入了一个连接池：</p><p> <img src="/2019/07/12/springboot/1525514424562.png" alt="1525514424562"></p><p>HikariCP应该是目前速度最快的连接池了，我们看看它与c3p0的对比：</p><p> <img src="/2019/07/12/springboot/1525516441005.png" alt="1525516441005"></p><p>因此，我们只需要指定连接池参数即可：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 连接四大参数</span><br><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/heima</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=123</span><br><span class="line"># 可省略，SpringBoot自动推断</span><br><span class="line">spring.datasource.driverClassName=com.mysql.jdbc.Driver</span><br><span class="line"></span><br><span class="line">spring.datasource.hikari.idle-timeout=60000</span><br><span class="line">spring.datasource.hikari.maximum-pool-size=30</span><br><span class="line">spring.datasource.hikari.minimum-idle=10</span><br></pre></td></tr></table></figure><p>当然，如果你更喜欢Druid连接池，也可以使用Druid官方提供的启动器：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Druid连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而连接信息的配置与上面是类似的，只不过在连接池特有属性上，方式略有不同：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#初始化连接数</span><br><span class="line">spring.datasource.druid.initial-size=1</span><br><span class="line">#最小空闲连接</span><br><span class="line">spring.datasource.druid.min-idle=1</span><br><span class="line">#最大活动连接</span><br><span class="line">spring.datasource.druid.max-active=20</span><br><span class="line">#获取连接时测试是否可用</span><br><span class="line">spring.datasource.druid.test-on-borrow=true</span><br><span class="line">#监控页面启动</span><br><span class="line">spring.datasource.druid.stat-view-servlet.allow=true</span><br></pre></td></tr></table></figure><h2 id="5-4-整合mybatis"><a href="#5-4-整合mybatis" class="headerlink" title="5.4.整合mybatis"></a>5.4.整合mybatis</h2><h3 id="5-4-1-mybatis"><a href="#5-4-1-mybatis" class="headerlink" title="5.4.1.mybatis"></a>5.4.1.mybatis</h3><p>SpringBoot官方并没有提供Mybatis的启动器，不过Mybatis<a href="https://github.com/mybatis/spring-boot-starter" target="_blank" rel="noopener">官网</a>自己实现了：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置，基本没有需要配置的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mybatis 别名扫描</span><br><span class="line">mybatis.type-aliases-package=com.heima.pojo</span><br><span class="line"># mapper.xml文件位置,如果没有映射文件，请注释掉</span><br><span class="line">mybatis.mapper-locations=classpath:mappers/*.xml</span><br></pre></td></tr></table></figure><p>需要注意，这里没有配置mapper接口扫描包，因此我们需要给每一个Mapper接口添加<code>@Mapper</code>注解，才能被识别。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-2-通用mapper"><a href="#5-4-2-通用mapper" class="headerlink" title="5.4.2.通用mapper"></a>5.4.2.通用mapper</h3><p>通用Mapper的作者也为自己的插件编写了启动器，我们直接引入即可：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通用mapper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>tk.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不需要做任何配置就可以使用了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">tk</span>.<span class="title">mybatis</span>.<span class="title">mapper</span>.<span class="title">common</span>.<span class="title">Mapper</span>&lt;<span class="title">User</span>&gt;</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-5-启动测试"><a href="#5-5-启动测试" class="headerlink" title="5.5.启动测试"></a>5.5.启动测试</h2><p>将controller进行简单改造：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">this</span>.userService.queryById(<span class="number">8L</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们启动项目，查看：</p><p> <img src="/2019/07/12/springboot/1525516714124.png" alt="1525516714124"></p><h1 id="6-Thymeleaf快速入门"><a href="#6-Thymeleaf快速入门" class="headerlink" title="6.Thymeleaf快速入门"></a>6.Thymeleaf快速入门</h1><p>SpringBoot并不推荐使用jsp，但是支持一些模板引擎技术：</p><p><img src="/2019/07/12/springboot/1525517263421.png" alt="1525517263421"></p><p>以前大家用的比较多的是Freemarker，但是我们今天的主角是Thymeleaf！</p><h2 id="6-1-为什么是Thymeleaf？"><a href="#6-1-为什么是Thymeleaf？" class="headerlink" title="6.1.为什么是Thymeleaf？"></a>6.1.为什么是Thymeleaf？</h2><p>简单说， Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。相较与其他的模板引擎，它有如下三个极吸引人的特点：</p><ul><li>动静结合：Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。</li><li>开箱即用：它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、该jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。</li><li>多方言支持：Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。</li><li>与SpringBoot完美整合，SpringBoot提供了Thymeleaf的默认配置，并且为Thymeleaf设置了视图解析器，我们可以像以前操作jsp一样来操作Thymeleaf。代码几乎没有任何区别，就是在模板语法上有区别。</li></ul><p>接下来，我们就通过入门案例来体会Thymeleaf的魅力：</p><h2 id="6-2-编写接口"><a href="#6-2-编写接口" class="headerlink" title="6.2.编写接口"></a>6.2.编写接口</h2><p>编写一个controller，返回一些用户数据，放入模型中，等会在页面渲染</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/all"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">all</span><span class="params">(ModelMap model)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询用户</span></span><br><span class="line">    List&lt;User&gt; users = <span class="keyword">this</span>.userService.queryAll();</span><br><span class="line">    <span class="comment">// 放入模型</span></span><br><span class="line">    model.addAttribute(<span class="string">"users"</span>, users);</span><br><span class="line">    <span class="comment">// 返回模板名称（就是classpath:/templates/目录下的html文件名）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"users"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-3-引入启动器"><a href="#6-3-引入启动器" class="headerlink" title="6.3.引入启动器"></a>6.3.引入启动器</h2><p>直接引入启动器：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SpringBoot会自动为Thymeleaf注册一个视图解析器：</p><p> <img src="/2019/07/12/springboot/1525522481007.png" alt="1525522481007"></p><p>与解析JSP的InternalViewResolver类似，Thymeleaf也会根据前缀和后缀来确定模板文件的位置：</p><p> <img src="/2019/07/12/springboot/1525522811359.png" alt="1525522811359"></p><ul><li>默认前缀：<code>classpath:/templates/</code></li><li>默认后缀：<code>.html</code></li></ul><p>所以如果我们返回视图：<code>users</code>，会指向到 <code>classpath:/templates/users.html</code></p><p>一般我们无需进行修改，默认即可。</p><h2 id="6-4-静态页面"><a href="#6-4-静态页面" class="headerlink" title="6.4.静态页面"></a>6.4.静态页面</h2><p>根据上面的文档介绍，模板默认放在classpath下的templates文件夹，我们新建一个html文件放入其中：</p><p> <img src="/2019/07/12/springboot/1525521721279.png" alt="1525521721279"></p><p>编写html模板，渲染模型中的数据：</p><p>注意，把html 的名称空间，改成：<code>xmlns:th=&quot;http://www.thymeleaf.org&quot;</code> 会有语法提示</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">        table &#123;border-collapse: collapse; font-size: 14px; width: 80%; margin: auto&#125;</span><br><span class="line">        table, th, td &#123;border: 1px solid darkslategray;padding: 10px&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"text-align: center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"color: darkslategray; font-size: 30px"</span>&gt;</span>欢迎光临！<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>id<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>生日<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>备注<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">"user : $&#123;users&#125;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.id&#125;"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.name&#125;"</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.userName&#125;"</span>&gt;</span>zhangsan<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.age&#125;"</span>&gt;</span>20<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.sex&#125; == 1 ? '男': '女'"</span>&gt;</span>男<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;#dates.format(user.birthday, 'yyyy-MM-dd')&#125;"</span>&gt;</span>1980-02-30<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.note&#125;"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们看到这里使用了以下语法：</p><ul><li><code>${}</code> ：这个类似与el表达式，但其实是ognl的语法，比el表达式更加强大</li><li><code>th-</code>指令：<code>th-</code>是利用了Html5中的自定义属性来实现的。如果不支持H5，可以用<code>data-th-</code>来代替<ul><li><code>th:each</code>：类似于<code>c:foreach</code>  遍历集合，但是语法更加简洁</li><li><code>th:text</code>：声明标签中的文本<ul><li>例如<code>&lt;td th-text=&#39;${user.id}&#39;&gt;1&lt;/td&gt;</code>，如果user.id有值，会覆盖默认的1</li><li>如果没有值，则会显示td中默认的1。这正是thymeleaf能够动静结合的原因，模板解析失败不影响页面的显示效果，因为会显示默认值！</li></ul></li></ul></li></ul><h2 id="6-5-测试"><a href="#6-5-测试" class="headerlink" title="6.5.测试"></a>6.5.测试</h2><p>接下来，我们打开页面测试一下：</p><p><img src="/2019/07/12/springboot/1525523911854.png" alt="1525523911854"></p><h2 id="6-6-模板缓存"><a href="#6-6-模板缓存" class="headerlink" title="6.6.模板缓存"></a>6.6.模板缓存</h2><p>Thymeleaf会在第一次对模板解析之后进行缓存，极大的提高了并发处理能力。但是这给我们开发带来了不便，修改页面后并不会立刻看到效果，我们开发阶段可以关掉缓存使用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 开发阶段关闭thymeleaf的模板缓存</span><br><span class="line">spring.thymeleaf.cache=false</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><pre><code>在Idea中，我们需要在修改页面后按快捷键：`Ctrl + Shift + F9` 对项目进行rebuild才可以。eclipse中没有测试过。</code></pre><p>我们可以修改页面，测试一下。</p>]]></content>
      
      
      <categories>
          
          <category> 后端框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
